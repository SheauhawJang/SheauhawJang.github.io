{"meta":{"title":"孤星捧月堂","subtitle":"Sheauhaw Jang's Blog","description":"一个 ICPCer 的学习笔记","author":"Sheauhaw Jang","url":"https://SheauhawJang.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-24T17:47:04.790Z","updated":"2020-08-14T11:52:12.000Z","comments":false,"path":"categories/index.html","permalink":"https://sheauhawjang.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-24T17:47:16.874Z","updated":"2020-08-15T14:26:12.000Z","comments":false,"path":"links/index.html","permalink":"https://sheauhawjang.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-24T17:50:19.529Z","updated":"2020-08-14T11:51:58.000Z","comments":false,"path":"tags/index.html","permalink":"https://sheauhawjang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2023 ICPC 陕西省赛 J 题题解","slug":"2023 Shaanxi Provincial J","date":"2023-05-26T08:32:06.000Z","updated":"2023-05-27T12:36:36.000Z","comments":true,"path":"2023/05/26/2023 Shaanxi Provincial J/","link":"","permalink":"https://sheauhawjang.github.io/2023/05/26/2023%20Shaanxi%20Provincial%20J/","excerpt":"题目来源: 2023 ICPC 陕西省赛: J. Teleport 题目链接: 暂无 题面 在 \\(n\\times n\\) 的网格中, 有些格点可以通过 (用.表示), 有些格点不可通过 (用*表示). 你需要从 \\((1,1)\\) 移动到 \\((n,n)\\). 保证 \\((1,1)\\) 和 \\((n,n)\\) 两个点是可以通过的. 当你在 \\((x,y)\\) 时, 你可以在一个单位时间内移动到以下点中的一个: \\((x+1,y)\\) 或 \\((x-1,y)\\) 或 \\((x,y+1)\\) 或 \\((x,y-1)\\); \\(f^i(x,y)\\), 其中 \\(i\\) 是任意的整数 \\(i\\le k\\). 不能移动到不可通过的点或者地图外的点. \\(f^i(x,y)\\) 的定义为: \\[ f^i(x,y)=\\begin{cases}(x,y)&amp;i=0\\\\f^{i-1}(y+1,x)&amp;i&gt;0\\end{cases} \\] 求从 \\((1,1)\\) 移动到 \\((n,n)\\) 的最短时间, 无解输出 -1. 数据范围 \\[ 1\\le n,k\\le5000 \\]","text":"题目来源: 2023 ICPC 陕西省赛: J. Teleport 题目链接: 暂无 题面 在 \\(n\\times n\\) 的网格中, 有些格点可以通过 (用.表示), 有些格点不可通过 (用*表示). 你需要从 \\((1,1)\\) 移动到 \\((n,n)\\). 保证 \\((1,1)\\) 和 \\((n,n)\\) 两个点是可以通过的. 当你在 \\((x,y)\\) 时, 你可以在一个单位时间内移动到以下点中的一个: \\((x+1,y)\\) 或 \\((x-1,y)\\) 或 \\((x,y+1)\\) 或 \\((x,y-1)\\); \\(f^i(x,y)\\), 其中 \\(i\\) 是任意的整数 \\(i\\le k\\). 不能移动到不可通过的点或者地图外的点. \\(f^i(x,y)\\) 的定义为: \\[ f^i(x,y)=\\begin{cases}(x,y)&amp;i=0\\\\f^{i-1}(y+1,x)&amp;i&gt;0\\end{cases} \\] 求从 \\((1,1)\\) 移动到 \\((n,n)\\) 的最短时间, 无解输出 -1. 数据范围 \\[ 1\\le n,k\\le5000 \\] 题解 对于题面给出的两种移动方式, 总共有 \\(4+k\\) 种可能到达的点, 直接进行 BFS 复杂度为 \\(O(n^2k)\\), 不能接受. 现将两种移动方式分开处理, 移动方式 1 是普通移动, 移动方式 2 是空間移動テレポート. 其中普通移动有 \\(4\\) 条路可以走, 空间移动有 \\(k\\) 条路可以走. 注意到, 在 BFS 过程中, 如果 \\(f^i(x,y)\\) 点已经因空间移动而被 BFS 过, 则从 \\(f^j(x,y)\\) 开始进行 BFS 时, \\(f^{1}(x,y),f^2(x,y),\\cdots,f^{i-j}(x,y)\\) 均已经因空间移动而被 BFS 过, 不需要再考虑到这些点的空间移动, 只需要考虑 \\(i-j\\) 阶之后的 Teleport 即可. 根据这一特性, 每一个点至多被空间移动到一次. 复杂度为 \\(O(n^2)\\). 需要注意的是, 本题的空间上限为 256 MiB, 在进行 BFS 的过程中, 队列需要 \\(3n^2\\) 大小的数组, 如果采用 int 数组, 则需要 286 MiB 的内存. 因此需要关注空间使用情况: 使用 short 数组或使用 STL std::queue. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; point;int n, k;bool bfsed[5003][5003];bool teled[5003][5003];bool pass[5003][5003];point teleport(int x, int y, int k)&#123; int hk = k &gt;&gt; 1; if (k &amp; 1) return &#123;y + hk + 1, x + hk&#125;; return &#123;x + hk, y + hk&#125;;&#125;void add_bfs(int x, int y, int depth, queue&lt;pair&lt;point, int&gt;&gt; &amp;bfs)&#123; if (!bfsed[x][y] &amp;&amp; pass[x][y]) &#123; bfsed[x][y] = true; bfs.push(&#123;&#123;x, y&#125;, depth&#125;); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; char sym; cin &gt;&gt; sym; if (sym == '.') pass[i][j] = true; else pass[i][j] = false; &#125; queue&lt;pair&lt;point, int&gt;&gt; bfs; add_bfs(1, 1, 0, bfs); int ans = -1; while (!bfs.empty()) &#123; point np = bfs.front().first; int dep = bfs.front().second; bfs.pop(); int x = np.first, y = np.second; if (x == n &amp;&amp; y == n) &#123; ans = dep; break; &#125; int maxk = min(min(2 * (n - x) + 1, 2 * (n - y)), min(n + n - x - y, k)); for (int i = maxk; i &gt; 0; --i) &#123; point tp = teleport(x, y, i); int tx = tp.first, ty = tp.second; if (teled[tx][ty]) break; teled[tx][ty] = true; add_bfs(tx, ty, dep + 1, bfs); &#125; add_bfs(x + 1, y, dep + 1, bfs); add_bfs(x - 1, y, dep + 1, bfs); add_bfs(x, y + 1, dep + 1, bfs); add_bfs(x, y - 1, dep + 1, bfs); &#125; cout &lt;&lt; ans;&#125;","categories":[{"name":"2023 ICPC","slug":"2023-ICPC","permalink":"https://sheauhawjang.github.io/categories/2023-ICPC/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"BFS","slug":"BFS","permalink":"https://sheauhawjang.github.io/tags/BFS/"}]},{"title":"2023 ICPC 陕西省赛 D 题题解","slug":"2023 Shaanxi Provincial D","date":"2023-05-25T05:33:00.000Z","updated":"2023-05-25T17:52:51.000Z","comments":true,"path":"2023/05/25/2023 Shaanxi Provincial D/","link":"","permalink":"https://sheauhawjang.github.io/2023/05/25/2023%20Shaanxi%20Provincial%20D/","excerpt":"题目来源: 2023 ICPC 陕西省赛: D. Function 题目链接: 暂无 题面 给定函数 \\(f\\) 满足: \\[ f(x)=\\begin{cases} \\displaystyle 1+\\sum_{k=2}^a f(kx)&amp;x\\le n\\\\ 0&amp;x&gt;n \\end{cases} \\] 输入 \\(n\\), 求 \\(f(1)\\bmod p\\). 其中 \\(a=20210926\\), \\(p=998244353\\). 数据范围 \\[ 1\\le n\\le10^9 \\]","text":"题目来源: 2023 ICPC 陕西省赛: D. Function 题目链接: 暂无 题面 给定函数 \\(f\\) 满足: \\[ f(x)=\\begin{cases} \\displaystyle 1+\\sum_{k=2}^a f(kx)&amp;x\\le n\\\\ 0&amp;x&gt;n \\end{cases} \\] 输入 \\(n\\), 求 \\(f(1)\\bmod p\\). 其中 \\(a=20210926\\), \\(p=998244353\\). 数据范围 \\[ 1\\le n\\le10^9 \\] 题解 本质上, 题设给出的函数是一个关于 \\(x\\) 和 \\(n\\) 的二元函数, 记: \\[ F(x,n)=\\begin{cases} \\displaystyle 1+\\sum_{k=2}^a F(kx,n)&amp;x\\le n\\\\ 0&amp;x&gt;n \\end{cases} \\] 可知 \\(f(x)=F(x,n)\\). 在题解的后文中将完全不再使用题面所给出的一元函数 \\(f\\), 均使用二元函数 \\(F\\). 题面所求转换为求 \\(F(1,n)\\bmod p\\). 根据 \\(F\\) 的定义, 可知: \\[ F(x,y)=F\\left(\\frac xz,\\frac yz\\right)=F\\left(1,\\frac yx\\right)\\tag1 \\] 记 \\(g(y)=F(1,y)\\). 则所求转换为求 \\(g(n)\\), 且有下式成立: \\[ g(y)=1+\\sum_{k=2}^a g\\left(\\frac yk\\right) \\] 此时, 根据该式直接进行记忆化搜索, 复杂度为 \\(O(n^2)\\), 显然不能满意. 而对于 \\(F(x,y)\\), 当 \\(x\\) 是正整数时, 有\\(\\newcommand{\\flor}[1]{\\left\\lfloor#1\\right\\rfloor}\\) \\[ F(x,y)=F(x,\\flor y)\\tag2 \\] 故可以得到 \\[ g(y)=1+\\sum_{k=2}^a g\\left(\\flor{\\frac yk}\\right) \\] 在这种情况下, 可以进行数论分块, \\(\\flor{y/k}\\) 只有 \\(O(\\sqrt y)\\) 个取值. 依托数论分块进行记忆化搜索求解 \\(g(n)\\): 对于 \\(\\flor{n/k}\\le \\sqrt n\\) 的情况, 将 \\(g(1),g(2),\\cdots,g(\\sqrt n)\\) 全部进行预处理, 共需求解 \\(\\sqrt n\\) 个值, 在数论分块的情况下, 每个值有 \\(O(\\sqrt{\\sqrt n})\\) 项相加, 该情况下的总复杂度为 \\(O(n^{3/4})\\). 对于 \\(\\flor{n/k}&gt;\\sqrt n\\) 的情况, 此时可知 \\(k&lt;\\sqrt n\\), 此时记 \\(h_n(k)=g(\\flor{n/k})\\), 则需求解 \\(h_n(1),h_n(2),\\cdots,h_n(\\sqrt n)\\). 其中 \\(h_n(k)\\) 共有 \\(O(\\sqrt{n/k})\\)​ 项相加, 该情况下的总复杂度为 \\[ \\sum_{k=1}^\\sqrt nO\\left(\\sqrt {\\frac{n}{k}}\\right)=O(\\sqrt n)\\cdot\\sum_{k=1}^{\\sqrt n}\\frac1{\\sqrt k}=O(\\sqrt n)\\cdot O\\left(\\sqrt{\\sqrt n}\\right)=O(n^{3/4}) \\] 故记忆化搜索的总复杂度为 \\(O(n^{3/4})\\). 需要注意在数论分块时, 分块的边界除了算法本身的 \\(n/(n/k)\\), 还要注意 \\(k\\le a\\). 即分块区间为 \\[ \\left[k,\\min\\left(\\flor{\\frac n{\\flor{n/k}}},a\\right)\\right] \\] 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int m = 1e9, ghn = sqrt(m);const int p = 998244353;int g[ghn + 7], h[ghn + 7], n;int solve(int hi)&#123; int ans = 1; int hn = n / hi; if (hn &lt;= ghn) return g[hn]; if (h[hi]) return h[hi]; for (int j = 2; j &lt;= hn &amp;&amp; j &lt;= 20210926; ++j) &#123; int jp = min(hn / (hn / j), 20210926); if (hn / j &lt;= ghn) ans += 1ll * (jp - j + 1) % p * g[hn / j] % p, ans %= p, j = jp; else ans += solve(hn / j), ans %= p; &#125; return h[hi] = ans;&#125;int main()&#123; for (int i = 1; i &lt;= ghn; ++i) &#123; g[i] = 1; for (int j = 2; j &lt;= i &amp;&amp; j &lt;= 20210926; ++j) &#123; int jp = i / (i / j); g[i] += 1ll * (jp - j + 1) % p * g[i / j] % p, g[i] %= p, j = jp; &#125; &#125; cin &gt;&gt; n; int ans; if (n &lt;= ghn) ans = g[n]; else ans = solve(1); cout &lt;&lt; ans;&#125;","categories":[{"name":"2023 ICPC","slug":"2023-ICPC","permalink":"https://sheauhawjang.github.io/categories/2023-ICPC/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"C#程序设计 第8周题解","slug":"CSharp Week8","date":"2020-12-08T08:31:48.000Z","updated":"2020-12-08T08:31:52.000Z","comments":true,"path":"2020/12/08/CSharp Week8/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week8/","excerpt":"A. 多态练习一工资系统 实现课本例9-3题目要求。根据4类不同员工类型分别进行工资的计算。 抽象基类Employee表示员工，这个类派生出SalariedEmployee、HourlyEmplyee和CommissionEmployee类，CommissionEmployee类派生出BasePlusCommissionEmployee类。（课本例9-3图） 1.固定工：每周工资一样，与工作时间长短无关，由SalariedEmployee类实现； 2.计时工：按时计酬，超过40小时算加班工资，由HourlyEmplyee类实现； 3.雇佣员工：按销售百分比例计算，由CommissionEmployee类实现； 4.底薪雇佣员工：在底薪之上增加销售百分比。在本期内，公司准备对底薪雇佣员工升薪10%，由BasePlusCommissionEmployee类实现。 在主函数中 创建4个派生类的对象，调用Earning(）方法输出。 多态的使用，创建含有4个派生类元素的Employee数组，调用Earning(）方法输出。 【注：】此题编译通过即可","text":"A. 多态练习一工资系统 实现课本例9-3题目要求。根据4类不同员工类型分别进行工资的计算。 抽象基类Employee表示员工，这个类派生出SalariedEmployee、HourlyEmplyee和CommissionEmployee类，CommissionEmployee类派生出BasePlusCommissionEmployee类。（课本例9-3图） 1.固定工：每周工资一样，与工作时间长短无关，由SalariedEmployee类实现； 2.计时工：按时计酬，超过40小时算加班工资，由HourlyEmplyee类实现； 3.雇佣员工：按销售百分比例计算，由CommissionEmployee类实现； 4.底薪雇佣员工：在底薪之上增加销售百分比。在本期内，公司准备对底薪雇佣员工升薪10%，由BasePlusCommissionEmployee类实现。 在主函数中 创建4个派生类的对象，调用Earning(）方法输出。 多态的使用，创建含有4个派生类元素的Employee数组，调用Earning(）方法输出。 【注：】此题编译通过即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;// Written by Sheauhaw Jang// 2020-11-10 10:54:13namespace CSharp_Week7_A&#123; abstract class Employee &#123; public string Name &#123; get; protected set; &#125; public Employee(string namae) &#123; Name = namae; &#125; public abstract double GetSal(); public virtual void Clear() &#123; &#125; public void WriteName() &#123; Console.WriteLine(Name); &#125; public void Earning() &#123; Console.WriteLine(GetSal()); &#125; &#125; class SalariedEmployee : Employee &#123; public double Bsal &#123; get; set; &#125; public SalariedEmployee(string namae, double x) : base(namae) &#123; Bsal = x; Clear(); &#125; public override double GetSal() &#123; return Bsal; &#125; &#125; class HourlyEmployee : Employee &#123; public double SalPrh &#123; get; protected set; &#125; public int WorkT &#123; get; set; &#125; public HourlyEmployee(string namae, double preh) : base(namae) &#123; SalPrh = preh; &#125; public void NoteWork(int t) &#123; WorkT += t; &#125; public override void Clear() &#123; WorkT = 0; &#125; const int HourLaw = 40; public override double GetSal() &#123; if (WorkT &lt;= HourLaw) return SalPrh * WorkT; else return SalPrh * HourLaw + 1.5 * SalPrh * (WorkT - HourLaw); &#125; &#125; class CommissionEmployee : Employee &#123; double Rate &#123; get; set; &#125; double ComVa &#123; get; set; &#125; public CommissionEmployee(string namae, double x) : base(namae) &#123; Rate = x; &#125; public override void Clear() &#123; ComVa = 0; &#125; public void NoteCom(double x) &#123; ComVa += x; &#125; public override double GetSal() &#123; return ComVa * Rate; &#125; &#125; class BasePlusCommissionEmployee : CommissionEmployee &#123; public double Bsal &#123; get; set; &#125; public BasePlusCommissionEmployee(string namae, double x, double r) : base(namae, r) &#123; Bsal = x; &#125; public override double GetSal() &#123; return base.GetSal() + Bsal; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Employee[] eps = new Employee[4]; SalariedEmployee epa = new SalariedEmployee(\"A\", 10000); HourlyEmployee epb = new HourlyEmployee(\"B\", 250); epb.NoteWork(50); CommissionEmployee epc = new CommissionEmployee(\"C\", 0.05); epc.NoteCom(1e7); BasePlusCommissionEmployee epd = new BasePlusCommissionEmployee(\"D\", 10000, 0.05); epd.NoteCom(1e7); eps[0] = epa; eps[1] = epb; eps[2] = epc; eps[3] = epd; foreach (Employee ep in eps) &#123; ep.WriteName(); ep.Earning(); &#125; &#125; &#125;&#125; B. 工资系统+生日 修改例题9-3，在Employee类中添加新的字段birthDate表示员工的生日。（如：DateTime dt=new DateTime(2000,12,21)） birthDate的数据类型为DateTime结构体类型（C#自带）。假设工资每月处理一次。 创建Employee数组，存储不同类型员工对象的引用。 可以循环输出每种类型员工的姓名和工资。如果本月是员工的生日，则工资增加100元。 【注：】本题编译通过即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384using System;// Written by Sheauhaw Jang// 2020-11-10 10:54:13namespace CSharp_Week7_A&#123; abstract class Employee &#123; public string Name &#123; get; protected set; &#125; public DateTime Birth &#123; get; set; &#125; public Employee(string namae) &#123; Name = namae; Birth = new DateTime(1900, 1, 1); &#125; public bool Bouns() &#123; return DateTime.Now.Month == Birth.Month; &#125; public abstract double GetSal(); public virtual void Clear() &#123; &#125; public void SetBirth(int y, int m, int d) &#123; Birth = new DateTime(y, m, d); &#125; public void WriteName() &#123; Console.WriteLine(Name); &#125; public double GetTotSal() &#123; return GetSal() + (Bouns() ? 100 : 0); &#125; public void Earning() &#123; Console.WriteLine(GetTotSal()); &#125; &#125; class SalariedEmployee : Employee &#123; public double Bsal &#123; get; set; &#125; public SalariedEmployee(string namae, double x) : base(namae) &#123; Bsal = x; Clear(); &#125; public override double GetSal() &#123; return Bsal; &#125; &#125; class HourlyEmployee : Employee &#123; public double SalPrh &#123; get; protected set; &#125; public int WorkT &#123; get; set; &#125; public HourlyEmployee(string namae, double preh) : base(namae) &#123; SalPrh = preh; &#125; public void NoteWork(int t) &#123; WorkT += t; &#125; public override void Clear() &#123; WorkT = 0; &#125; const int HourLaw = 40; public override double GetSal() &#123; if (WorkT &lt;= HourLaw) return SalPrh * WorkT; else return SalPrh * HourLaw + 1.5 * SalPrh * (WorkT - HourLaw); &#125; &#125; class CommissionEmployee : Employee &#123; double Rate &#123; get; set; &#125; double ComVa &#123; get; set; &#125; public CommissionEmployee(string namae, double x) : base(namae) &#123; Rate = x; &#125; public override void Clear() &#123; ComVa = 0; &#125; public void NoteCom(double x) &#123; ComVa += x; &#125; public override double GetSal() &#123; return ComVa * Rate; &#125; &#125; class BasePlusCommissionEmployee : CommissionEmployee &#123; public double Bsal &#123; get; set; &#125; public BasePlusCommissionEmployee(string namae, double x, double r) : base(namae, r) &#123; Bsal = x; &#125; public override double GetSal() &#123; return base.GetSal() + Bsal; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Employee[] eps = new Employee[4]; SalariedEmployee epa = new SalariedEmployee(\"A\", 10000); epa.SetBirth(1926, 8, 17); eps[0] = epa; HourlyEmployee epb = new HourlyEmployee(\"B\", 250); epb.SetBirth(1997, 7, 1); epb.NoteWork(50); eps[1] = epb; CommissionEmployee epc = new CommissionEmployee(\"C\", 0.05); epc.NoteCom(1e7); epc.SetBirth(2002, 8, 17); eps[2] = epc; BasePlusCommissionEmployee epd = new BasePlusCommissionEmployee(\"D\", 10000, 0.05); epd.NoteCom(1e7); epd.SetBirth(2020, 11, 30); eps[3] = epd; foreach (Employee ep in eps) &#123; ep.WriteName(); ep.Earning(); &#125; &#125; &#125;&#125; C. 工资系统+计件工 修改例题9-3，增加Employee类的另一个派生类PieceWorker，表示计件工。 PieceWorker类具有专用的实例变量wage和pieces分别表示每件的工资和生产的件数。 在PieceWorker类中提供Earning方法的具体实现，计算员工的收入。计算方法是将件数乘以每件的工资。 创建一个Employee数组，存储新的类层次中每个具体类对象的引用，显示每个员工收入。 【注：】本题编译通过即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;// Written by Sheauhaw Jang// 2020-11-10 10:54:13namespace CSharp_Week7_C&#123; abstract class Employee &#123; public string Name &#123; get; protected set; &#125; public DateTime Birth &#123; get; set; &#125; public Employee(string namae) &#123; Name = namae; Birth = new DateTime(1900, 1, 1); &#125; public bool Bouns() &#123; return DateTime.Now.Month == Birth.Month; &#125; public abstract double GetSal(); public virtual void Clear() &#123; &#125; public void SetBirth(int y, int m, int d) &#123; Birth = new DateTime(y, m, d); &#125; public void WriteName() &#123; Console.WriteLine(Name); &#125; public double GetTotSal() &#123; return GetSal() + (Bouns() ? 100 : 0); &#125; public void Earning() &#123; Console.WriteLine(GetTotSal()); &#125; &#125; class SalariedEmployee : Employee &#123; public double Bsal &#123; get; set; &#125; public SalariedEmployee(string namae, double x) : base(namae) &#123; Bsal = x; Clear(); &#125; public override double GetSal() &#123; return Bsal; &#125; &#125; class HourlyEmployee : Employee &#123; public double SalPrh &#123; get; protected set; &#125; public int WorkT &#123; get; set; &#125; public HourlyEmployee(string namae, double preh) : base(namae) &#123; SalPrh = preh; &#125; public void NoteWork(int t) &#123; WorkT += t; &#125; public override void Clear() &#123; WorkT = 0; &#125; const int HourLaw = 40; public override double GetSal() &#123; if (WorkT &lt;= HourLaw) return SalPrh * WorkT; else return SalPrh * HourLaw + 1.5 * SalPrh * (WorkT - HourLaw); &#125; &#125; class CommissionEmployee : Employee &#123; double Rate &#123; get; set; &#125; double ComVa &#123; get; set; &#125; public CommissionEmployee(string namae, double x) : base(namae) &#123; Rate = x; &#125; public override void Clear() &#123; ComVa = 0; &#125; public void NoteCom(double x) &#123; ComVa += x; &#125; public override double GetSal() &#123; return ComVa * Rate; &#125; &#125; class BasePlusCommissionEmployee : CommissionEmployee &#123; public double Bsal &#123; get; set; &#125; public BasePlusCommissionEmployee(string namae, double x, double r) : base(namae, r) &#123; Bsal = x; &#125; public override double GetSal() &#123; return base.GetSal() + Bsal; &#125; &#125; class PieceWorker : Employee &#123; double wage &#123; get; set; &#125; int pieces &#123; get; set; &#125; public PieceWorker(string namae, double x) : base(namae) &#123; wage = x; &#125; public override void Clear() &#123; pieces = 0; &#125; public void NotePieces(int x) &#123; pieces += x; &#125; public override double GetSal() &#123; return pieces * wage; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Employee[] eps = new Employee[5]; SalariedEmployee epa = new SalariedEmployee(\"A\", 10000); epa.SetBirth(1926, 8, 17); eps[0] = epa; HourlyEmployee epb = new HourlyEmployee(\"B\", 250); epb.SetBirth(1997, 7, 1); epb.NoteWork(50); eps[1] = epb; CommissionEmployee epc = new CommissionEmployee(\"C\", 0.05); epc.NoteCom(1e7); epc.SetBirth(2002, 8, 17); eps[2] = epc; BasePlusCommissionEmployee epd = new BasePlusCommissionEmployee(\"D\", 10000, 0.05); epd.NoteCom(1e7); epd.SetBirth(2020, 11, 30); eps[3] = epd; PieceWorker epe = new PieceWorker(\"E\", 100); epe.NotePieces(100); epe.SetBirth(2077, 12, 31); eps[4] = epe; foreach (Employee ep in eps) &#123; ep.WriteName(); ep.Earning(); &#125; &#125; &#125;&#125; D. 类和接口 定义一个动物类Animal，包含字段姓名、年龄，有1个带参数的构造方法，初始化2个私有字段。抽象方法叫Shout(); 鸽子类派生自Animal，新增私有字段羽毛（默认白色）；覆写方法Shout()，方法体输出相关信息（自己组织格式）*岁的鸽子姓名咕咕叫； 猫类派生自Animal，新增属性胡须长度；覆写方法Shout(），方法体输出相关信息（自己组织格式）*岁的小猫姓名喵喵叫； 定义一个交通工具类Vehicle，包含颜色，品牌。有1个无参数的构造方法，初始化2个私有字段（默认值自己给）。 派生类飞机继承Vehicle。新增飞行高度属性。 定义接口IFly，包含方法Fly()。鸽子类、飞机类均继承该接口，实现Fly()。鸽子类的Fly()方法，输出*颜色的鸽子飞。飞机类的Fly()方法输出*品牌的飞机飞行在*千米的高空。 在主函数中生成对象，测试类中的方法。 【注：】本题编译通过即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;// Written by Sheauhaw Jang// 2020-11-10 11:12:50namespace CSharp_Week7_D&#123; interface IFly &#123; void Fly(); &#125; abstract class Animal &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public Animal(string namae, int x) &#123; Name = namae; Age = x; &#125; public abstract void Shout(); &#125; class Pigeon : Animal, IFly &#123; public int Wing &#123; get; set; &#125; public Pigeon(string namae, int x) : base(namae, x) &#123; Wing = 0xffffff; &#125; public override void Shout() &#123; Console.WriteLine(\"&#123;0&#125;岁的鸽子&#123;1&#125;咕咕叫\", Age, Name); &#125; public void Fly() &#123; Console.WriteLine(\"&#123;0&#125;颜色的鸽子飞\", string.Format(\"#&#123;0:X&#125;\", Wing)); &#125; &#125; class Cat : Animal &#123; public int Leng &#123; get; set; &#125; public Cat(string namae, int x) : base(namae, x) &#123; Leng = 0; &#125; public override void Shout() &#123; Console.WriteLine(\"&#123;0&#125;岁的小猫&#123;1&#125;喵喵叫\", Age, Name); &#125; &#125; class Vehicle &#123; public int Color &#123; get; set; &#125; public string Company &#123; get; set; &#125; public Vehicle() &#123; Color = 0xffffff; Company = \"XJTU\"; &#125; &#125; class Plane : Vehicle, IFly &#123; public int Height &#123; get; set; &#125; public void Fly() &#123; Console.WriteLine(\"&#123;0&#125;品牌的飞机飞行在&#123;1&#125;千米的高空\", Company, Height); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Pigeon zdk = new Pigeon(\"Zeondik\", 18); zdk.Shout(); zdk.Fly(); Plane fakeloc = new Plane(); fakeloc.Height = 114514; fakeloc.Fly(); &#125; &#125;&#125; E. *选做*——窗体程序“计算利率” 学习MOOC视频12.4例题计算利率，完成以下窗体程序。 要求： 1.熟悉Visual Studio新建Windows Form项目； 2.按照图示设计界面； \\3. 编写“确定”按钮的事件。 4.运行程序，输入“本金”、“利率”，选择“年龄”，点击“确定”按钮，“本息合计”显示计算结果。 【注】本题自愿完成。 解决方案","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第7周题解","slug":"CSharp Week7","date":"2020-12-08T08:26:20.000Z","updated":"2020-12-08T08:26:22.000Z","comments":true,"path":"2020/12/08/CSharp Week7/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week7/","excerpt":"A. Circle类的继承 定义圆类Circle，包含半径r，属性R能判断半径r的合理性（r&gt;0），计算圆面积的方法double Area()。 从Circle类派生出圆柱体类Cylinder类。该类新增圆柱体的高h，属性H能判断高h的合理性（h&gt;0），新增计算圆柱体体积的方法double Volume()。 如果半径、高不合法，就设置其值为0。 在Main方法中，创建一个Cylinder对象，输入半径和高（两行输入），并输出该对象的底面半径，高，底面积以及体积（面积和体积用double Math.round(doulbe b, int digit) digit取1。 （要求：不使用构造方法，并且类中的字段为私有，方法为公有）","text":"A. Circle类的继承 定义圆类Circle，包含半径r，属性R能判断半径r的合理性（r&gt;0），计算圆面积的方法double Area()。 从Circle类派生出圆柱体类Cylinder类。该类新增圆柱体的高h，属性H能判断高h的合理性（h&gt;0），新增计算圆柱体体积的方法double Volume()。 如果半径、高不合法，就设置其值为0。 在Main方法中，创建一个Cylinder对象，输入半径和高（两行输入），并输出该对象的底面半径，高，底面积以及体积（面积和体积用double Math.round(doulbe b, int digit) digit取1。 （要求：不使用构造方法，并且类中的字段为私有，方法为公有） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;// Written by Sheauhaw Jang// 2020-11-03 10:10:09namespace CSharp_Week6_A&#123; class Circle &#123; private double r; public double R &#123; get &#123; return r; &#125; set &#123; r = value &gt; 0 ? value : 0; &#125; &#125; public double Area() &#123; return Math.PI * R * R; &#125; &#125; class Cylinder : Circle &#123; private double h; public double H &#123; get &#123; return h; &#125; set &#123; h = value &gt; 0 ? value : 0; &#125; &#125; public double Volume() &#123; return Area() * H; &#125; &#125; static class OutputConvert &#123; public static void OutputString(string sop, params double[] opv) &#123; string[] ops = new string[4]; for (int i = 0; i &lt; 4; ++i) &#123; opv[i] = Math.Round(opv[i], 1); ops[i] = Convert.ToString(opv[i]); &#125; Console.WriteLine(string.Join(\" \", ops)); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Cylinder ans = new Cylinder(); ans.R = Convert.ToDouble(Console.ReadLine()); ans.H = Convert.ToDouble(Console.ReadLine()); OutputConvert.OutputString(\" \", ans.R, ans.H, ans.Area(), ans.Volume()); &#125; &#125;&#125; B. Circle类的继承——带参构造方法 定义圆类Circle，包含半径r，属性R能判断半径r的合理性（r&gt;0），计算圆面积的方法double Area()。 从Circle类派生出圆柱体类Cylinder类。该类新增圆柱体的高h，属性H能判断高h的合理性（h&gt;0），新增计算圆柱体体积的方法double Volume()。 如果半径、高不合法，就设置其值为0。 在Main方法中，创建一个Cylinder对象，输入半径和高（两行输入），并输出该对象的底面积、体积。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;// Written by Sheauhaw Jang// 2020-11-03 10:27:06namespace CSharp_Week6_B&#123; class Circle &#123; private double r; public double R &#123; get &#123; return r; &#125; set &#123; r = value &gt; 0 ? value : 0; &#125; &#125; public double Area() &#123; return Math.PI * R * R; &#125; &#125; class Cylinder : Circle &#123; private double h; public double H &#123; get &#123; return h; &#125; set &#123; h = value &gt; 0 ? value : 0; &#125; &#125; public double Volume() &#123; return Area() * H; &#125; &#125; static class OutputConvert &#123; public static void OutputString(string sop, params double[] opv) &#123; string[] ops = new string[opv.Length]; for (int i = 0; i &lt; opv.Length; ++i) &#123; opv[i] = Math.Round(opv[i], 1); ops[i] = Convert.ToString(opv[i]); &#125; Console.WriteLine(string.Join(\" \", ops)); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Cylinder ans = new Cylinder(); ans.R = Convert.ToDouble(Console.ReadLine()); ans.H = Convert.ToDouble(Console.ReadLine()); OutputConvert.OutputString(\" \", ans.Area(), ans.Volume()); &#125; &#125;&#125; C. 点线类练习 从点类（Point）：包含：带可选参数的构造方法Point（int x=0, int y=0)， 输出坐标点的方法ShowPoint以及读写坐标x、y的属性方法。 派生类（Line）：计算线段的长度。Line类中新增表示线段终点的字段EndPoint，起点字段StartPoint。 计算线段距离的方法Distance以及输出线段起点和终点的方法ShowLine。 在主函数中，创建两个点对象，输出线段的距离。 【注：】本题编译通过即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;// Written by Sheauhaw Jang// 2020-11-03 11:09:15namespace CSharp_Week6_C&#123; class Point &#123; public const int dim = 2; private int[] xs = new int[dim]; public int X &#123; get &#123; return xs[0]; &#125; set &#123; xs[0] = value; &#125; &#125; public int Y &#123; get &#123; return xs[1]; &#125; set &#123; xs[1] = value; &#125; &#125; public int At(int x) &#123; return x &lt; dim ? xs[x] : 0; &#125; public Point(int x = 0, int y = 0) &#123; X = x; Y = y; &#125; public void ShowPoint() &#123; Console.WriteLine(\"(&#123;0&#125;, &#123;1&#125;)\", X, Y); &#125; &#125; class Line &#123; Point StartPoint, EndPoint; public Line(Point sp, Point ep) &#123; StartPoint = sp; EndPoint = ep; &#125; public void ShowLine() &#123; Console.Write(\"StartPoint:\"); StartPoint.ShowPoint(); Console.Write(\"EndPoint:\"); EndPoint.ShowPoint(); &#125; Func&lt;int, int&gt; sq = x =&gt; x * x; public double Distance() &#123; int sqd = 0; for (int i = 0; i &lt; Point.dim; ++i) sqd += sq(StartPoint.At(i) - EndPoint.At(i)); return Math.Sqrt(sqd); &#125; public void ShowDistance() &#123; Console.WriteLine(Distance()); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Point a = new Point(0, 0); Point b = new Point(1, 1); Line ab = new Line(a, b); ab.ShowDistance(); &#125; &#125;&#125; D. Student类的继承练习 实现两个类。 StuGrade类。该类的作用是成绩相关的操作。包括： 私有字段 int[] gra（学生成绩）； 构造函数 StuGrade(params int[] stusgra)；用于初始化私有字段gra； 公有方法 public double AvgGrade()；返回学生成绩的平均值。 Student类。包含： 2个public 自实现属性string Name（学生姓名）、string StuNum（学号）； 1个private字段 string stuClass（学生班级）； 1个StuGrade对象 stuG； 1个公有方法public bool IsStuNo(string s,out int res)。检测学号是否合法。其中s是待检查的学号。学号必须是8位数字，21开头。不是8位数字res置1，非21开头res置2。合法res=学号。 1个公有方法public bool AddStu(string name, string sno, StuGrade stug, string stuclass= \"数学\")。如果学号合法的对象，将姓名、学号、成绩、班级（默认是数学）赋值，返回true。否则，不赋值，返回false。 在Main函数中，新建Student类对象stu，并接收控制台输入的信息. 【样例输入】 姓名,学号 成绩 如果输入学号合法，输出 学号:Success!AverageGrade:平均分 如果输入学号非法，输出 学号:Invalid!Error Code:res的值 例如： 新建对象Student stu1，尝试对stu1设置信息Alex,20812000, 成绩是：1, 2, 3, 4, 5。将按照如下格式输出 20812000:Invalid!Error Code:2 新建Student类对象stu2 ，尝试对stu2设置信息Bob,21812000, 成绩是：1, 2, 3。将按照如下格式输出 21812000:Success!AverageGrade:2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System;// Written by Sheauhaw Jang// 2020-11-03 10:30:01namespace CSharp_Week6_D&#123; class StuGrade &#123; private int[] gra; public StuGrade(params int[] stusgra) &#123; gra = stusgra; &#125; public double AvgGrade() &#123; double ans = 0; foreach (int sig in gra) ans += sig; ans /= gra.Length; return ans; &#125; &#125; class Student &#123; public string Name &#123; get; set; &#125; public string StuNum &#123; get; set; &#125; private string stuClass; StuGrade stuG; const int vlen = 8; const string chpre = \"21\"; public static bool IsStuNo(string s, out int res) &#123; if (s.Length != vlen) &#123; res = 1; return false; &#125; for (int i = 0; i &lt; chpre.Length; ++i) if (s[i] != chpre[i]) &#123; res = 2; return false; &#125; res = Convert.ToInt32(s); return true; &#125; public bool AddStu(string name, string sno, StuGrade stug, string stuclass = \"数学\") &#123; int nov; if (!IsStuNo(sno, out nov)) return false; Name = name; StuNum = sno; stuG = stug; stuClass = stuclass; return true; &#125; &#125; public static class InputConvert &#123; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string[] nameid = Console.ReadLine().Split(','); int res; if (!Student.IsStuNo(nameid[1], out res)) Console.WriteLine(\"&#123;0&#125;:Invalid!Error Code:&#123;1&#125;\", nameid[1], res); else &#123; StuGrade sg = new StuGrade(InputConvert.GetInputArray(',')); Console.WriteLine(\"&#123;0&#125;:Success!AverageGrade:&#123;1&#125;\", nameid[1], sg.AvgGrade()); &#125; &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第6周题解","slug":"CSharp Week6","date":"2020-12-08T08:20:08.000Z","updated":"2020-12-08T08:20:10.000Z","comments":true,"path":"2020/12/08/CSharp Week6/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week6/","excerpt":"A. 重载方法的练习 在Main函数所在的类，实现两个方法用于计算成绩的平均值，小数点后1位。 public static double AvgGrade(int[] gra) //数值型成绩的平均值。得分1~5之间。课程数无限制。 public static double AvgGrade(string[] sgra) //成绩分为“good”和“ok”两个等级。good等价于4分，ok等价于1分。 在Main方法中，分别调用两种方法，均能输出平均成绩。输入用空格分开。 【注:】 四舍五入的区别请大家了解https://www.cnblogs.com/fanyong/archive/2013/05/30/chinese_round.html 大家选取“传统意义上的四舍五入”的定义方法。 保留*位小数的方法请参考 https://blog.csdn.net/qq_40985921/article/details/85414484","text":"A. 重载方法的练习 在Main函数所在的类，实现两个方法用于计算成绩的平均值，小数点后1位。 public static double AvgGrade(int[] gra) //数值型成绩的平均值。得分1~5之间。课程数无限制。 public static double AvgGrade(string[] sgra) //成绩分为“good”和“ok”两个等级。good等价于4分，ok等价于1分。 在Main方法中，分别调用两种方法，均能输出平均成绩。输入用空格分开。 【注:】 四舍五入的区别请大家了解https://www.cnblogs.com/fanyong/archive/2013/05/30/chinese_round.html 大家选取“传统意义上的四舍五入”的定义方法。 保留*位小数的方法请参考 https://blog.csdn.net/qq_40985921/article/details/85414484 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;// Written by Sheauhaw Jang// 2020-10-27 10:33:00namespace CSharp_Week5_A&#123; static class InputConvert &#123; public static int[] ToInputArray(params string[] instr) &#123; int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; public static double AvgGrade(params int[] gra) &#123; double ans = 0; foreach (int sg in gra) ans += sg; ans /= gra.Length; //ans = Math.Round(ans, 1); return ans; &#125; public static double AvgGrade(params string[] sgra) &#123; int[] gra = new int[sgra.Length]; for (int i = 0; i &lt; sgra.Length; ++i) gra[i] = sgra[i] == \"good\" ? 4 : 1; return AvgGrade(gra); &#125; static void Main(string[] args) &#123; string[] ip = Console.ReadLine().Split(' '); double ans; if (ip[0][0] &gt;= '0' &amp;&amp; ip[0][0] &lt;= '9') ans = AvgGrade(InputConvert.ToInputArray(ip)); else ans = AvgGrade(ip); Console.WriteLine(\"&#123;0:0.0&#125;\", ans); &#125; &#125;&#125; B. 时间类 定义一个时间类。 成员有3个属性（包括对应的私有字段）年、月、日。属性要判断 年&gt;0、12&gt;=月份&gt;0、日&gt;0并要在所在月份天数之内。 一个构造方法，在构造方法中给属性赋值。 在program类中,定义一个方法，方法的两个参数就是时间类的对象。 方法的作用是，比较第一个参数（时间）和第二个参数（时间）的早晚，如果第一个时间早，返回1，相等返回0，小于返回-1。 在主函数main（）中调用该方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110using System;// Written by Sheauhaw Jang// 2020-10-27 11:07:40namespace CSharp_Week5_B&#123; static class InputConvert &#123; public static int[] ToInputArray(params string[] instr) &#123; int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Date &#123; const int datelen = 3; private int year = -1, month = -1, day = -1; int[] data = new int[datelen]; public bool Vaild &#123; get; private set; &#125; public int Year &#123; get &#123; return year; &#125; private set &#123; if (value &gt; 0) year = value; else Vaild = false; &#125; &#125; public int Month &#123; get &#123; return month; &#125; private set &#123; if (value &gt; 0 &amp;&amp; value &lt;= 12) month = value; else Vaild = false; &#125; &#125; int DayLimit() &#123; switch (Month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 4: case 6: case 9: case 11: return 30; case 2: if (Year % 400 == 0) return 29; else if (Year % 100 == 0) return 28; else if (Year % 4 == 0) return 29; else return 28; default: return -1; &#125; &#125; public int Day &#123; get &#123; return day; &#125; private set &#123; if (value &gt; 0 &amp;&amp; value &lt;= DayLimit()) day = value; else Vaild = false; &#125; &#125; void Update(params int[] ip) &#123; Vaild = true; for (int i = 0; i &lt; datelen &amp;&amp; i &lt; ip.Length; ++i) data[i] = ip[i]; Year = data[0]; Month = data[1]; Day = data[2]; &#125; void Update(params string[] sip) &#123; Update(InputConvert.ToInputArray(sip)); &#125; void Update(string date, char soperator) &#123; Update(date.Split(soperator)); &#125; public Date(params int[] ip) &#123; Update(ip); &#125; public Date(params string[] sip) &#123; Update(sip); &#125; public Date(string date, char soperator = '/') &#123; Update(date, soperator); &#125; public int CompareTo(Date b) &#123; for (int i = 0; i &lt; datelen; ++i) &#123; if (data[i] &lt; b.data[i]) return -1; if (data[i] &gt; b.data[i]) return 1; &#125; return 0; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string[] line = Console.ReadLine().Split(' '); Date[] cmp = new Date[line.Length]; for (int i = 0; i &lt; line.Length; ++i) cmp[i] = new Date(line[i]); Console.WriteLine(-cmp[0].CompareTo(cmp[1])); &#125; &#125;&#125; C. 控制台交互式小程序练习 开发计算机辅助教学程序，教小学生学乘法。程序功能： （1）程序开始时让用户选择“年级”为1或2。一年级使只用1位数乘法；二年级使用2位数乘法。 （2）用Random对象产生两个1位或2位正整数，然后输出以下问题，例如： How much is 6 times 7? 然后学生输入答案，程序检查学生的答案。如果正确，则打印“Very good!”，然后提出另一个乘法问题。如果不正确，则打印“No,Please try again.”，然后让学生重复回答这个问题，直到答对。 （3）答对3道题后程序结束。 （4）每个新的问题要求使用一个单独方法产生， 这个方法在程序开始时和每次用户答对时调用。 【注：】此程序无测试用例，编译通过即可。 偷懒了，没写。","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第5周题解","slug":"CSharp Week5","date":"2020-12-08T08:16:31.000Z","updated":"2020-12-08T08:16:34.000Z","comments":true,"path":"2020/12/08/CSharp Week5/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week5/","excerpt":"A. 属性的使用 定义Rectangle类，类中的两个属性Length和Width（其对应的私有字段为length和width，默认值为均为1）。 Length属性的set方法中验证其值必须在0~20（开区间）之间的浮点数。如果不满足保持其默认值。 方法： 计算长方形的周长public double Perimeter() 计算长方形的面积public double Area() 输入长方形的长和宽的值，输出长方形的周长、面积。","text":"A. 属性的使用 定义Rectangle类，类中的两个属性Length和Width（其对应的私有字段为length和width，默认值为均为1）。 Length属性的set方法中验证其值必须在0~20（开区间）之间的浮点数。如果不满足保持其默认值。 方法： 计算长方形的周长public double Perimeter() 计算长方形的面积public double Area() 输入长方形的长和宽的值，输出长方形的周长、面积。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;// Written by Sheauhaw Jang// 2020-10-20 10:15:50namespace CSharp_Week4_A&#123; class Rectangle &#123; double length = 1; double width = 1; double Length &#123; get &#123; return length; &#125; set &#123; if (value &gt; 0 &amp;&amp; value &lt; 20) length = value; &#125; &#125; double Width &#123; get &#123; return width; &#125; set &#123; width = value; &#125; &#125; public Rectangle() &#123; &#125; public Rectangle(double l, double w) &#123; Length = l; Width = w; &#125; public double Perimeter() &#123; return 2 * (length + width); &#125; public double Area() &#123; return length * width; &#125; &#125; static class InputConvert &#123; public static double[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); double[] invar = new double[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToDouble(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; double[] lenwid = InputConvert.GetInputArray(' '); Rectangle tim = new Rectangle(lenwid[0], lenwid[1]); Console.WriteLine(tim.Perimeter()); Console.WriteLine(tim.Area()); &#125; &#125;&#125; B. 利用一维数组求解问题。 读入若干（1-15个）整数（一行输入，空格分隔），每个数在10-100之间的整数包括10和100。 在读入每个数时，确认这个数的有效性（在10到100之间），并且若它和之前读入的数不一样，就把它存储到数组中，无效的数不存储。 读完所有数之后，仅显示用户输入的不同的数值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System;using System.Collections;// Written by Sheauhaw Jang// 2020-10-20 10:48:45namespace CSharp_Week4_B&#123; class NumberPile &#123; static readonly int[] range = &#123; 10, 100 &#125;; readonly bool[] check = new bool[range[1] - range[0] + 1]; ArrayList save = new ArrayList(); public NumberPile() &#123; for (int i = 0; i &lt; check.Length; ++i) check[i] = false; &#125; public bool CheckIn(int x) &#123; if (x &lt; range[0] || x &gt; range[1]) return false; return check[x - range[0]]; &#125; public bool CheckChange(int x) &#123; if (x &lt; range[0] || x &gt; range[1]) return false; return check[x - range[0]] = true; &#125; public void Push(params int[] xs) &#123; foreach (int x in xs) if (x &gt;= range[0] &amp;&amp; x &lt;= range[1]) if (!CheckIn(x)) &#123; save.Add(x); CheckChange(x); &#125; &#125; public void Write() &#123; Console.WriteLine(string.Join(\" \", save.ToArray())); &#125; &#125; static class InputConvert &#123; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; NumberPile p = new NumberPile(); p.Push(InputConvert.GetInputArray(' ')); p.Write(); &#125; &#125;&#125; C. 成绩排序 创建一个学生类。 字段：学号（string类型）、成绩（用一个一维数组，存储一个学生的5门课成绩） 方法：将学生的5门课成绩由小到大顺序输出。 主函数中，声明3个学生对象，从控制台给每个学生的学号和5门课成绩赋值，调用方法输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;namespace CSharp_Week4_C&#123; class Student &#123; string name; const int subnum = 5; int[] score = new int[subnum]; public Student() &#123; name = \"NoName\"; for (int i = 0; i &lt; subnum; ++i) score[i] = 0; &#125; public Student(params string[] info) &#123; if (info == null) return; if (info.Length &gt; 0) name = info[0]; for (int i = 0; i &lt; subnum; ++i) if (info.Length &gt; i + 1) score[i] = Convert.ToInt32(info[i + 1]); else score[i] = 0; &#125; public Student(string na, params int[] info) &#123; name = na; for (int i = 0; i &lt; subnum; ++i) if (info.Length &gt; i) score[i] = info[i]; else score[i] = 0; &#125; public void Sort() &#123; Array.Sort(score); &#125; public void Write() &#123; string[] info = new string[subnum + 1]; info[0] = name; for (int i = 0; i &lt; subnum; ++i) info[i + 1] = Convert.ToString(score[i]); Console.WriteLine(string.Join(\" \", info)); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; const int stunum = 3; for (int i = 0; i &lt; stunum; ++i) &#123; Student stu = new Student(Console.ReadLine().Split(' ')); stu.Sort(); stu.Write(); &#125; &#125; &#125;&#125; D. 洗牌与发牌 参照课本第五章【案例研究】——模拟洗牌与发牌。 此题目涉及多种概念，请大家参照课本（或MOOC视频）完成代码编写。 【注：】提交后，编译通过即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173using System;using System.Text;// Written by Sheauhaw Jang// 2020-10-19 11:57:10namespace CSharp_Week4_D&#123; class Card &#123; public int Number &#123; get; private set; &#125; public int Suit &#123; get; private set; &#125; public int Id &#123; get; private set; &#125; static string[] suits = new string[] &#123; \"♠\", \"♥\", \"♣\", \"♦\" &#125;; static string NumberName(int x) &#123; switch (x) &#123; case 1: return \"A\"; case 11: return \"J\"; case 12: return \"Q\"; case 13: return \"K\"; default: return Convert.ToString(x); &#125; &#125; public Card(int id) &#123; Id = id; Number = id / 4 + 1; Suit = id % 4; &#125; public Card(int num, int type) &#123; Id = 4 * Number - 4 + Suit; Number = num; Suit = type; &#125; public string GetSuitS() &#123; return suits[Suit]; &#125; public string GetNumberS() &#123; return NumberName(Number); &#125; public string GetName() &#123; return GetSuitS() + GetNumberS(); &#125; public int CompareTo(Card b) &#123; if (Id &lt; b.Id) return -1; if (Id &gt; b.Id) return 1; return 0; &#125; &#125; class PokerPile &#123; static int cardnum = 52; Card[] pcards = new Card[cardnum]; public PokerPile() &#123; for (int i = 0; i &lt; cardnum; ++i) pcards[i] = new Card(i); &#125; void swap(ref Card a, ref Card b) &#123; Card tmp = b; b = a; a = tmp; &#125; public void Shuffle(params int[] seed) &#123; Random tool; if (seed.Length == 0) &#123; Console.WriteLine(\"随机洗牌中......\"); tool = new Random(); &#125; else &#123; Console.WriteLine(\"作弊洗牌中......\"); string dinfo = string.Format(\"&#123;0:X&#125;\", seed[0]); while (dinfo.Length &lt; 8) dinfo = \"0\" + dinfo; dinfo = \"0x\" + dinfo; Console.WriteLine(\"种子为：&#123;0&#125;\", dinfo); tool = new Random(seed[0]); &#125; for (int i = 0; i &lt; cardnum; ++i) swap(ref pcards[i], ref pcards[tool.Next(i, cardnum)]); Console.WriteLine(\"洗牌完毕!\"); &#125; public void Sort() &#123; Console.WriteLine(\"恢复牌堆中......\"); Array.Sort(pcards, (a, b) =&gt; a.CompareTo(b)); Console.WriteLine(\"恢复完毕!\"); &#125; const int playernum = 4; readonly static string[] defname = new string[] &#123; \"甲\", \"乙\", \"丙\", \"丁\" &#125;; readonly static string[] align = new string[] &#123; \"第\", \"\", \"张：\", \"\", \"\\t\\t\" &#125;; const int alignlen = 7; int GetPreStr(string org) // 防止破坏格式, 字母1格, 非字母2格, 不得超过7格. &#123; int cnt = alignlen; for (int i = 0; i &lt; cnt &amp;&amp; i &lt; org.Length; ++i) if (org[i] &gt; 127) --cnt; return cnt; &#125; public void HandOut(params string[] name) &#123; Console.WriteLine(\"发牌中......\"); string[] rname = new string[playernum]; for (int i = 0; i &lt; playernum; ++i) if (name.Length &lt;= i || name[i].Length &lt; 1) rname[i] = defname[i]; else &#123; int remLen = GetPreStr(name[i]); if (remLen &lt; name[i].Length) rname[i] = name[i].Remove(remLen); else rname[i] = name[i]; &#125; for (int i = 0; i &lt; playernum; ++i) Console.Write(\"\\t&#123;0&#125;\\t\\t\", rname[i]); for (int i = 0; i &lt; cardnum; ++i) &#123; if (i % playernum == 0) Console.WriteLine(); string[] s = new string[align.Length]; Array.Copy(align, s, align.Length); s[1] = Convert.ToString(i + 1); while (s[1].Length &lt; 2) s[1] = \" \" + s[1]; s[3] = pcards[i].GetName(); Console.Write(string.Join(\"\", s)); &#125; Console.WriteLine(); Console.WriteLine(\"发牌完毕!\"); &#125; public void DoAsk() &#123; while (true) &#123; Console.Write(\"&gt;&gt; \"); string[] csla = Console.ReadLine().Split(' '); if (csla.Length == 0) continue; switch (csla[0]) &#123; case \"洗牌\": try &#123; Shuffle(Convert.ToInt32(csla[1])); &#125; catch &#123; Shuffle(); &#125; break; case \"恢复\": Sort(); break; case \"发牌\": string[] aft = new string[csla.Length - 1]; Array.Copy(csla, 1, aft, 0, aft.Length); HandOut(aft); break; case \"结束\": return; default: Console.WriteLine(\"命令未找到！\"); break; &#125; &#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Console.OutputEncoding = new UTF8Encoding(); PokerPile p = new PokerPile(); p.Shuffle(); p.HandOut(); p.Sort(); p.Shuffle(0x01315878); p.HandOut(\"徐忠锋\", \"乔亚男\", \"平田一郎\"); p.Sort(); p.HandOut(\"Zeondik,,Sheauhaw\".Split(',')); p.DoAsk(); &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第4周题解","slug":"CSharp Week4","date":"2020-12-08T08:14:17.000Z","updated":"2020-12-08T08:14:23.000Z","comments":true,"path":"2020/12/08/CSharp Week4/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week4/","excerpt":"A. 孪生素数查找程序 所谓孪生素数指的是间隔为2 的相邻素数，就像孪生兄弟。最小的孪生素数是(3, 5)，在100 以内的孪生素数还有(3,5), (5,7), (11,13),(17,19),(29,31),(41,43),(59,61),(71,73) 总计有 8 组。(备注：每组孪生素数之间用英文逗号,分隔） 输入正整数，输出小于等于number的孪生素数的组数。","text":"A. 孪生素数查找程序 所谓孪生素数指的是间隔为2 的相邻素数，就像孪生兄弟。最小的孪生素数是(3, 5)，在100 以内的孪生素数还有(3,5), (5,7), (11,13),(17,19),(29,31),(41,43),(59,61),(71,73) 总计有 8 组。(备注：每组孪生素数之间用英文逗号,分隔） 输入正整数，输出小于等于number的孪生素数的组数。 1234567891011121314151617181920212223242526272829303132333435363738394041using System;namespace CSharp_Week3_A&#123; public static class NumberChecker &#123; public static bool CheckPrime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) return false; return true; &#125; public static int NextNumber(int x) &#123; return x + 2; &#125; public static bool TwinPrime(int x) &#123; return CheckPrime(x) &amp;&amp; CheckPrime(NextNumber(x)); &#125; public static void WriteTwin(int x, ref bool split) &#123; if (split) Console.Write(\",\"); else split = true; Console.Write(\"(&#123;0&#125;,&#123;1&#125;)\", x, NextNumber(x)); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; bool split = false; int n = Convert.ToInt32(Console.ReadLine()); for (int i = 1; NumberChecker.NextNumber(i) &lt;= n; ++i) if (NumberChecker.TwinPrime(i)) NumberChecker.WriteTwin(i, ref split); &#125; &#125;&#125; B. 求a+aa+aaa+aaaa+...+aa...a 求a+aa+aaa+aaaa+...+aa...a(第n项，n个a)，其中a是1～9的整数。例如， a=1,n=3时，式子为1+11+111； 当a=6,n=5时，式子为5+55+555+5555+55555。 格式: 第一行为输入a n 第二行为输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;namespace CSharp_Week3_B&#123; public class Calculate &#123; int a, n; long[] save; long ans = 0; void update() &#123; if (n &lt; 1) return; save = new long[n]; save[0] = a; for (int i = 1; i &lt; n; ++i) save[i] = save[i - 1] * 10 + a; foreach (long sig in save) ans += sig; &#125; public Calculate(int va, int vn) &#123; a = va; n = vn; update(); &#125; public void SetDigit(int va) &#123; a = va; update(); &#125; public void SetLength(int vn) &#123; n = vn; update(); &#125; public long At(int x) &#123; return x &gt;= 0 &amp;&amp; x &lt; n ? save[x] : 0; &#125; public long Get(int len) &#123; return len &gt; 0 &amp;&amp; len &lt;= n ? save[len - 1] : 0; &#125; public long GetSum() &#123; return ans; &#125; public void WriteSum() &#123; Console.WriteLine(ans); &#125; &#125; public static class InputConvert &#123; public static int[] GetInputArray() &#123; string[] instr = Console.ReadLine().Split(' '); int[] invar = new int[instr.Length]; for (int i = 0; i&lt;invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; int[] an = InputConvert.GetInputArray(); Calculate equ = new Calculate(an[0], an[1]); equ.WriteSum(); &#125; &#125;&#125; C. 天数计算 输入公元年份和月份，输出该月份的天数。（用switch……case语句） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;namespace CSharp_Week3_C&#123; public static class InputConvert &#123; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; public static class DateCalculate &#123; public static int GetDays(int year, int month) &#123; switch(month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 4: case 6: case 9: case 11: return 30; case 2: if (year % 400 == 0) return 29; if (year % 100 == 0) return 28; if (year % 4 == 0) return 29; return 28; default: return 0; &#125; &#125; public static void WriteDays(int year, int month) &#123; Console.WriteLine(GetDays(year, month)); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; int[] ym = InputConvert.GetInputArray(','); DateCalculate.WriteDays(ym[0], ym[1]); &#125; &#125;&#125; D. 文字祖玛游戏 程序通过用户输入一个字符串（长度不超过30），由A、B、C、D、E五个字母组成，例如：ACBEEBBAD。 用户再输入一个字符，只能是A、B、C、D、E其中之一，然后再输入一个要插入的位置。 程序会将这个字符插入到字符串的指定位置前（第一个字符位置为0，第二个字符位置为1，依此类推），然后消除连续出现的三个相同的字符，直到没有连续三个相同的字符为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;namespace CSharp_Week3_D&#123; public class ZumaMap &#123; string map; static int rule = 3; public ZumaMap() &#123; map = Console.ReadLine(); &#125; public ZumaMap(string s) &#123; map = s; &#125; public string GetMap() &#123; return map; &#125; public void WriteMap() &#123; Console.WriteLine(map); &#125; public bool AutoRemove() &#123; for (int i = 0; i + rule &lt;= map.Length; ++i) &#123; bool check = true; for (int j = 1; j &lt; rule; ++j) if (map[i + j] != map[i]) &#123; check = false; break; &#125; if (check) &#123; map = map.Remove(i, rule); return true; &#125; &#125; return false; &#125; public void Update() &#123; while (AutoRemove()) ; &#125; public void Insert(int insloc, char insvar) &#123; map = map.Insert(insloc, Convert.ToString(insvar)); Update(); &#125; &#125; public static class InputConvert &#123; public static string[] GetInputStrings(char SplitOperator) &#123; return Console.ReadLine().Split(SplitOperator); &#125; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; ZumaMap map = new ZumaMap(); string[] insertinfo = InputConvert.GetInputStrings(' '); int insloc = Convert.ToInt32(insertinfo[1]); char insvar = Convert.ToChar(insertinfo[0]); map.Insert(insloc, insvar); map.WriteMap(); &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第3周题解","slug":"CSharp Week3","date":"2020-12-08T08:10:47.000Z","updated":"2020-12-08T08:10:49.000Z","comments":true,"path":"2020/12/08/CSharp Week3/","link":"","permalink":"https://sheauhawjang.github.io/2020/12/08/CSharp%20Week3/","excerpt":"A. 输入输出练习 在一行内输入5个整数，空格分隔。输出5个整数，逗号分隔。英文符号。（输入的接收请参考课本例题1-5,注意Split()的用法）","text":"A. 输入输出练习 在一行内输入5个整数，空格分隔。输出5个整数，逗号分隔。英文符号。（输入的接收请参考课本例题1-5,注意Split()的用法） 1234567891011121314151617181920212223242526272829using System;// Written by Sheauhaw Jang// 2020-10-14 13:10:22namespace CSharp_Week2_A&#123; public static class InputConvert &#123; public static string[] GetInputStrings(char SplitOperator) &#123; return Console.ReadLine().Split(SplitOperator); &#125; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = GetInputStrings(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string[] numstr = InputConvert.GetInputStrings(' '); Console.WriteLine(string.Join(\",\", numstr)); &#125; &#125;&#125; B. 三角形的类和方法 定义一个三角型类，具有3个public的字段（double）为三角形的3边的长度。提供2个public的方法： bool IsTriAngle（）判断这3边能否构成一个三角形； double Area（） 求三角形的面积（如果不能构成三角形，返回值为-1） 输入三角形的3条边，用空格分隔。如果能构成三角形，直接输出三角形面积；否则输出-1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;// Written by Sheauhaw Jang// 2020-10-14 13:19:31namespace CSharp_Week2_B&#123; class TriAngle &#123; static int sidenumber = 3; double[] sides = new double[sidenumber]; bool vaild; double totlen, area; bool TriAngleVaildCheck() &#123; for (int i = 0; i &lt; sidenumber; ++i) if (totlen &lt;= 2 * sides[i]) return false; return true; &#125; double AreaCalculate() &#123; double barlen = totlen / 2; double ans = barlen; for (int i = 0; i &lt; sidenumber; ++i) ans *= barlen - sides[i]; return Math.Sqrt(ans); &#125; void update(double[] x) &#123; totlen = 0; for (int i = 0; i &lt; x.Length &amp;&amp; i &lt; sidenumber; ++i) sides[i] = x[i]; for (int i = 0; i &lt; sidenumber; ++i) totlen += sides[i]; vaild = TriAngleVaildCheck(); area = vaild ? AreaCalculate() : 0; &#125; public TriAngle(double[] x) &#123; update(x); &#125; public TriAngle(double a, double b, double c) &#123; update(new double[]&#123; a, b, c &#125;); &#125; public bool IsTriAngle() &#123; return vaild; &#125; public double Area() &#123; return area; &#125; &#125; public static class InputConvert &#123; public static double[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); double[] invar = new double[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToDouble(instr[i]); return invar; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; TriAngle tri = new TriAngle(InputConvert.GetInputArray(' ')); if (tri.IsTriAngle()) Console.WriteLine(tri.Area()); else Console.WriteLine(-1); &#125; &#125;&#125; C. 日期Date类 创建一个Date类，要求能输入以下格式的日期： 第一种：MM/YYYY 构造函数接收2个整数 第二种：June,1992 构造函数接收一个字符串和一个整数 当用户输入其出生年月日时，能够计算出用户的年龄（到年即可。向下取整）。当用户输入的日期无意义或未来时间，输出invalid。（当前时间取系统时间，请查C#自带的取时间的函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System;// Written by Sheauhaw Jang// 2020-10-19 11:36:13namespace CSharp_Week2_C&#123; class Date &#123; static string[] engname = new string[] &#123; \"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" &#125;; public int Year &#123; get; private set; &#125; public int Month &#123; get; private set; &#125; public static int NowYear() &#123; return DateTime.Now.Year; &#125; public static int NowMonth() &#123; return DateTime.Now.Month; &#125; void SetTypeNum(string date) &#123; string[] spdate = date.Split('/'); if (spdate.Length != 2) return; Year = Convert.ToInt32(spdate[1]); Month = Convert.ToInt32(spdate[0]); &#125; void SetTypeEng(string date) &#123; string[] spdate = date.Split(','); if (spdate.Length != 2) return; Year = Convert.ToInt32(spdate[1]); for (int i = 1; i &lt;= 12; ++i) if (spdate[0] == engname[i]) Month = i; &#125; void SetDefault() &#123; Year = Month = 0; &#125; public Date() &#123; SetDefault(); &#125; public Date(string date) &#123; SetDefault(); if (date[2] == '/') SetTypeNum(date); else SetTypeEng(date); &#125; public bool Vaild() &#123; if (Month &lt; 1 || Month &gt; 12) return false; if (Year &gt; NowYear()) return false; if (Year == NowYear() &amp;&amp; Month &gt; NowMonth()) return false; return true; &#125; public int GetAge() &#123; return NowYear() - Year; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string date = Console.ReadLine(); Date birth = new Date(date); if (birth.Vaild()) Console.WriteLine(\"&#123;0&#125;岁\", birth.GetAge()); else Console.WriteLine(\"invalid\"); &#125; &#125;&#125; D. 心率检查 运动时，可以利用心率监测仪来查看心率是否处于安全范围内。其中最高心率=220-年龄；目标心率是最高心率的50%-85%（向下取整）； 创建一个名称为HeartRates的类。这个类的的属性应该包含人的姓名、出生年份和当前年份。 类中还包含一个计算并返回年龄（以整年计算）的属性；一个计算并返回最高心率分方法；以及2个分别计算最低和最高目标心率的方法； 编写程序，实例化HeartRates类，输入个人姓名，出生年月日（空格分隔）。并输出对象的信息，包括姓名，出生年份；年龄；最高心率，最低目标心率，最高目标心率（空格分隔） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;// Written by Sheauhaw Jang// 2020-10-19 11:55:43namespace CSharp_Week2_D&#123; public static class InputConvert &#123; public static int[] GetInputArray(char SplitOperator) &#123; string[] instr = Console.ReadLine().Split(SplitOperator); int[] invar = new int[instr.Length]; for (int i = 0; i &lt; invar.Length; ++i) invar[i] = Convert.ToInt32(instr[i]); return invar; &#125; &#125; class HeartRates &#123; public string Name &#123; get; private set; &#125; public int Year &#123; get; private set; &#125; public int Month &#123; get; private set; &#125; public int Days &#123; get; private set; &#125; public static int NowYear() &#123; return DateTime.Now.Year; &#125; void SetTypeNum(string date) &#123; string[] spdate = date.Split('/'); Year = Convert.ToInt32(spdate[0]); Month = Convert.ToInt32(spdate[1]); Days = Convert.ToInt32(spdate[2]); &#125; void SetDefault() &#123; Year = Month = Days = 0; &#125; public HeartRates() &#123; SetDefault(); &#125; public HeartRates(string[] info) &#123; SetDefault(); Name = info[0]; SetTypeNum(info[1]); &#125; public int GetAge() &#123; return NowYear() - Year; &#125; public int MaxRates() &#123; return 220 - GetAge(); &#125; public int MinGoalRates() &#123; return (int)(MaxRates() * 0.5); &#125; public int MaxGoalRates() &#123; return (int)(MaxRates() * 0.85); &#125; public string GetInfoLine() &#123; string[] info = new string[6]; info[0] = Name; info[1] = Convert.ToString(Year) + \"年\"; info[2] = Convert.ToString(GetAge()) + \"岁\"; info[3] = \"最高心率\" + Convert.ToString(MaxRates()); info[4] = \"最低目标心率\" + Convert.ToString(MinGoalRates()); info[5] = \"最高目标心率\" + Convert.ToString(MaxGoalRates()); return string.Join(\" \", info); &#125; public void WriteInfoLine() &#123; Console.WriteLine(GetInfoLine()); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string[] infos = Console.ReadLine().Split(' '); HeartRates peo = new HeartRates(infos); peo.WriteInfoLine(); &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"C#程序设计 第2周题解","slug":"CSharp Week2","date":"2020-09-23T04:23:27.000Z","updated":"2020-09-23T04:23:27.000Z","comments":true,"path":"2020/09/23/CSharp Week2/","link":"","permalink":"https://sheauhawjang.github.io/2020/09/23/CSharp%20Week2/","excerpt":"A. 计算两个数的和、差、商、积。 从键盘分别输入两个不为0的整数（前2行输入），分别输出这两个整数的和 差 积 商。","text":"A. 计算两个数的和、差、商、积。 从键盘分别输入两个不为0的整数（前2行输入），分别输出这两个整数的和 差 积 商。 12345678910111213141516171819202122232425262728293031323334using System;// Written by Sheauhaw Jang// 2020-09-22 10:50:57namespace CSharp_Week1_A&#123; public class Calculate &#123; public static int Get(int a, int b, int type) &#123; switch(type) &#123; case 0: return a + b; case 1: return a - b; case 2: return a * b; case 3: return a / b; &#125; return 0; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; int a = Convert.ToInt32(Console.ReadLine()); int b = Convert.ToInt32(Console.ReadLine()); for (int i = 0; i &lt; 4; ++i) &#123; if (i &gt; 0) Console.Write(' '); Console.Write(Calculate.Get(a, b, i)); &#125; &#125; &#125;&#125; B. 时间转换 输入表示时间的整数，单位是秒。输出*天*小时*分*秒。 如果时间单位前的数值是0，则不输出该时间单位的数值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;// Written by Sheauhaw Jang// 2020-09-22 11:17:04namespace CSharp_Week1_B&#123; public class TimeManager &#123; public static long day = 60 * 60 * 24; public static long hour = 60 * 60; public static long minute = 60; public static long second = 1; public static long[] units = &#123; day, hour, minute, second &#125;; public static string[] unitsName = &#123; \"天\", \"小时\", \"分\", \"秒\" &#125;; public static long GetUnitCount(long tVar, int type) &#123; if (type != 0) tVar %= units[type - 1]; return tVar / units[type]; &#125; public static bool WriteUnitCount(long tVar, int type) &#123; long ans = GetUnitCount(tVar, type); if (ans == 0) return false; Console.Write(ans); Console.Write(unitsName[type]); return true; &#125; public static bool WriteCount(long tVar) &#123; bool ans = false; for (int i = 0; i &lt; units.Length; ++i) if (WriteUnitCount(tVar, i)) ans = true; return ans; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; long tVar = Convert.ToInt64(Console.ReadLine()); TimeManager.WriteCount(tVar); &#125; &#125;&#125; C. 整数加密 对于一个4位整数（从0000-9999）按如下方式加密：将每位数字加7后对10取余，用余数替换原来的数字；然后将1,3位数字互换；2,4位数字互换。 输入一个4位数，输出加密后的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;// Written by Sheauhaw Jang// 2020-09-22 11:44:47namespace CSharp_Week1_C&#123; public class Encode &#123; static int AddModulo(int x, int p) &#123; return x &gt;= p ? x - p : x; &#125; static void Swap&lt;T&gt;(ref T a, ref T b) &#123; T tmp = b; b = a; a = tmp; &#125; public static int[] DoEncoding(string x) &#123; int[] code = new int[x.Length]; for (int i = 0; i &lt; x.Length; ++i) &#123; code[i] = x[i] - '0'; code[i] = AddModulo(code[i] + 7, 10); &#125; Swap(ref code[0], ref code[2]); Swap(ref code[1], ref code[3]); return code; &#125; public static void WriteCode(string x) &#123; int[] code = DoEncoding(x); foreach (int digit in code) Console.Write(digit); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; string x = Console.ReadLine(); Encode.WriteCode(x); &#125; &#125;&#125; D. 字符串输入输出 输入一个字符串，按照样例格式输出。 样例： Alice Hi Alice, Welcome to C# 2020! Best wishes! 1234567891011121314151617using System;// Written by Sheauhaw Jang// 2020-09-22 11:58:50namespace CSharp_Week1_D&#123; class Program &#123; static void Main(string[] args) &#123; string s = Console.ReadLine(); Console.WriteLine(\"Hi &#123;0&#125;,\", s); Console.WriteLine(\"Welcome to C# 2020!\"); Console.WriteLine(); Console.WriteLine(\"Best wishes!\"); &#125; &#125;&#125; E. 字符大小写转换 输入一个字母，如果它是小写字母则输出它的大写字母，如果它是大写字母输出它的小写字母。 123456789101112131415161718using System;// Written by Sheauhaw Jang// 2020-09-22 21:28:37namespace CSharp_Week1_E&#123; class Program &#123; static void Main(string[] args) &#123; int s = Console.Read(); if (s &gt;= 'a' &amp;&amp; s &lt;= 'z') s = s - 'a' + 'A'; else s = s - 'A' + 'a'; Console.WriteLine(Convert.ToChar(s)); &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"}]},{"title":"2020 XJTU 校队夏季训练8 E题题解","slug":"2020 Summer Training 8E","date":"2020-08-31T15:09:52.000Z","updated":"2020-09-01T14:27:04.000Z","comments":true,"path":"2020/08/31/2020 Summer Training 8E/","link":"","permalink":"https://sheauhawjang.github.io/2020/08/31/2020%20Summer%20Training%208E/","excerpt":"题目来源: 2019-2020 XX Opencup GP of Tokyo 题目链接: http://codeforces.com/gym/102586/problem/E 题面 一共 \\(T\\) 组数据. 现有 \\(k\\) 个 两两不同 的数字 \\(A_1,A_2,\\cdots,A_k\\). 给定正整数 \\(N,S\\), 构造数列 \\(a_1,a_2,\\cdots,a_N\\), 满足下列条件: \\(\\displaystyle\\sum_{i=1}^Na_i=S\\). \\(\\forall i\\in[1,N]\\), \\(a_i\\in\\{A_1,A_2,\\cdots,A_k\\}\\). 求构造的方案数在模 \\(\\mathbf 2\\) 意义下的结果. 数据范围 \\[ 1\\le T\\le 5 \\] \\[ 1\\le N\\le10^{18} \\] \\[ 0\\le S\\le 10^{18} \\] \\[ 1\\le k\\le 200 \\] \\[ 0\\le A_1&lt;A_2&lt;\\cdots&lt;A_k\\le10^5 \\]","text":"题目来源: 2019-2020 XX Opencup GP of Tokyo 题目链接: http://codeforces.com/gym/102586/problem/E 题面 一共 \\(T\\) 组数据. 现有 \\(k\\) 个 两两不同 的数字 \\(A_1,A_2,\\cdots,A_k\\). 给定正整数 \\(N,S\\), 构造数列 \\(a_1,a_2,\\cdots,a_N\\), 满足下列条件: \\(\\displaystyle\\sum_{i=1}^Na_i=S\\). \\(\\forall i\\in[1,N]\\), \\(a_i\\in\\{A_1,A_2,\\cdots,A_k\\}\\). 求构造的方案数在模 \\(\\mathbf 2\\) 意义下的结果. 数据范围 \\[ 1\\le T\\le 5 \\] \\[ 1\\le N\\le10^{18} \\] \\[ 0\\le S\\le 10^{18} \\] \\[ 1\\le k\\le 200 \\] \\[ 0\\le A_1&lt;A_2&lt;\\cdots&lt;A_k\\le10^5 \\] 题解 组合数学计算 若数列 \\(a\\) 满足题设条件, 则 \\(a\\) 由若干个 \\(A_1,A_2,\\cdots,A_k\\) 组成. 设 \\(a\\) 由 \\(t_i\\) 个 \\(A_i\\) (\\(i=1,2,\\cdots,k\\)) 组成, 则由题意有: \\[ \\begin{aligned} t_1A_1+t_2A_2+\\cdots+t_kA_k&amp;=S\\\\ t_1+t_2+\\cdots+t_k&amp;=N \\end{aligned}\\tag1 \\] 由于数列中的元素顺序任意交换后仍满足条件. 于是将命题 \\((1)\\) 对应的数列归为一类, 则这样的一类中的数列数量, 依组合数学, 可知: \\[ C=\\frac{N!}{t_1!t_2!\\cdots t_k!} \\] 注意到只考虑模 \\(2\\) 意义下的结果, 于是只考虑 \\(C\\bmod 2\\ne0\\) 的情况即可. 由于模数为 \\(2\\), 只要 \\(C\\bmod2\\ne0\\), 就一定有 \\(C\\bmod2=1\\), 对结果的贡献为 \\(1\\). 二进制拆位 定理 \\(n!\\) 的标准分解式为: \\[ n!=\\prod_{p}{p^{\\alpha(p,n)}} \\] \\[ \\newcommand{\\flor}[1]{\\left\\lfloor #1 \\right\\rfloor}\\alpha(p,n)=\\sum_{i}{\\left\\lfloor\\frac{n}{p^i}\\right\\rfloor} \\] 由上述定理, \\(C\\) 的标准分解式为: \\[ C=\\prod_{p}{p^{A_p}} \\] \\[ \\begin{aligned} A_p&amp;=\\sum_{i}{\\flor{\\frac{N}{p^i}}}-\\sum_{j=1}^k\\sum_{i}{\\flor{\\frac{t_j}{p^i}}}\\\\ &amp;=\\sum_{i}\\left(\\flor{\\frac{N}{p^i}}-\\sum_{j=1}^k\\flor{\\frac{t_j}{p^i}}\\right) \\end{aligned} \\] 于是, 对于任意素数 \\(p\\), \\(C\\bmod p\\ne0\\) 的充分必要条件是 \\(A_p=0\\). 由于 \\(\\forall i\\), \\[ \\sum_{j=1}^k\\flor{\\frac{t_j}{p^i}}\\le\\flor{\\sum_{j=1}^k\\frac{t_j}{p^i}}=\\flor{\\frac{N}{p^i}}\\tag2 \\] 于是 \\(A_p=0\\) 的充分必要条件是: \\(\\forall i\\), \\((2)\\) 式等号成立. 从 \\(p\\) 进制数运算的角度来看, \\(\\flor{x/p^i}\\) 就是 \\(x\\) 的 \\(p\\) 进制数去掉低 \\(i\\) 位的结果, 等号成立的条件就是 \\(t_1,t_2,\\cdots,t_k\\) 的低 \\(i\\) 位之和不会在第 \\(i+1\\) 位上产生进位. 因为: \\[ \\flor{\\frac{N}{p^i}}=\\flor{\\sum_{i=1}^k\\frac{t_j}{p^i}}=\\sum_{j=1}^k\\flor{\\frac{t_j}{p^i}}+\\flor{\\sum_{j=1}^k\\left\\{\\frac{t_j}{p^i}\\right\\}} \\] 其中: \\(\\{x\\}\\) 表示 \\(x\\) 的小数部分, \\(\\displaystyle\\flor{\\sum_{j=1}^k\\left\\{\\frac{t_j}{p^i}\\right\\}}\\) 就是产生的进位. 由于 \\(\\forall i\\), 第 \\(i\\) 位都不产生进位, 若用 \\(x[i]\\) 表示 \\(x\\) 的第 \\(i\\) 位数字 (最低位为 \\(0\\)), 则可以得到 \\(\\forall i\\), \\[ \\sum_{j=1}^kt_j[i]=N[i] \\] 对于上述命题, 考虑 \\(p=2\\) 的特例, 有一个比较好的性质: \\(C\\bmod 2\\) 的结果只有 \\(0,1\\) 两种取值. \\(\\forall i\\), \\(N[i]\\) 只有 \\(0,1\\) 两种取值. 若 \\(N[i]=0\\), 则 \\(t_1[i]=t_2[i]=\\cdots=t_k[i]=0\\). 否则, \\(t_1[i],t_2[i],\\cdots,t_k[i]\\) 中有且仅有一个 \\(1\\). 这时, 讨论 \\(t_1[i],t_2[i],\\cdots,t_k[i]\\) 哪个是 \\(1\\) 即可. 如果 \\(t_{xi}[i]=1\\), 则会带来 \\(2^{i-1}A_{xi}\\) 的贡献. 于是只需要讨论, 有多少种 \\(A_{x1}, A_{x2},\\cdots\\) 的选择方案, 使得 \\[ \\sum_{N[i]=1}2^{i-1}A_{xi}=S \\] 即可. 背包问题转化 对于选择方案, 其实本质是一个背包问题: 对于重量为 \\(2^{i-1}\\) 的物品, 若 \\(N[i]=1\\), 则你可以选择 \\(A_1,A_2,\\cdots,A_k\\) 个, 否则不能选择; 最终让背包容量为 \\(S\\). 令 \\(dp(i,v)\\) 为考虑了 \\(i\\) 位, 且已占用背包容量为 \\(v\\) 的方案数, 则状态转移为: \\[ dp(i,v)=\\begin{cases} \\displaystyle \\sum_{j=1}^kdp(i-1,v-2^{i-1}A_j)&amp; N[i]=1\\\\ dp(i-1,v)&amp;N[i]=0 \\end{cases} \\] 或者写为 \\[ dp(i,v)\\stackrel{+}\\longrightarrow \\begin{cases} dp(i+1,v+2^i A_j)&amp;j=1,2,\\cdots,k&amp;N[i]=1\\\\ dp(i+1,v)&amp;&amp;N[i]=0 \\end{cases} \\] 最终答案为 \\(dp(\\flor{\\log N}+1,S)\\). 时间复杂度为 \\(O(kS\\log N)\\), 不能接受, 考虑优化. 二进制优化 注意到考虑了 \\(i\\) 位后, 低 \\(i\\) 位的值不再改变. 我们只需要考虑低 \\(i\\) 位与 \\(S\\) 的低 \\(i\\) 位相同的情况即可, 转移的时候不需要再考虑这些, 这样我们只需要记录 \\(v\\) 去掉低 \\(i\\) 位后的值 \\(v&#39;\\) 即可. 记 \\(v=2^{i-1}v&#39;+S\\bmod 2^{i-1}\\), 于是状态转移变成了: \\[ dp(i,v&#39;)= \\begin{cases} \\displaystyle\\sum_{j=1}^kdp(i-1,2v&#39;+S[i]-A_j)&amp;j=1,2,\\cdots,k&amp;N[i]=1\\\\ dp(i-1,2v&#39;+S[i])&amp;&amp;N[i]=0 \\end{cases} \\] 或者写为: \\[ dp(i,v&#39;)\\stackrel{+}\\longrightarrow \\begin{cases} \\displaystyle dp\\left(i+1,\\frac{v&#39;+A_j-S[i]}2\\right)&amp;j=1,2,\\cdots,k&amp;N[i]=1\\\\ \\displaystyle dp\\left(i+1,\\frac{v&#39;-S[i]}2\\right)&amp;&amp;N[i]=0 \\end{cases}\\tag3 \\] 最终答案即 \\(dp(\\flor{\\log N}+1, 0)\\). 记 \\(\\boldsymbol A:=\\{A_1,A_2,\\cdots,A_k\\}\\), \\(\\bar A=\\sup\\boldsymbol A\\) 若 \\(v&#39;\\le\\bar A\\), 则 \\[ \\frac{v&#39;+A_j-S[i]}{2}\\le\\frac{\\bar A+\\bar A-S[i]}{2}\\le\\bar A \\] 由于状态边界 \\(dp(0,0)=1\\) 的 \\(v&#39;=0\\le\\bar A\\), 于是所有有效的状态都满足 \\(v&#39;\\le\\bar A\\), 状态转移时 \\(v&#39;&gt;\\bar A\\) 的情况不再考虑. 于是时间复杂度为 \\(O(k\\bar A\\log N)\\), 空间复杂度 \\(O(\\bar A\\log N)\\). Bitset 优化 由于动态转移的过程是模 \\(2\\) 意义下的加法, 本质上是 \\(0,1\\) 之间的异或, 自然考虑 bitset 优化的可能性. bitset 可以快速地进行整体异或, 左移, 右移等操作. 如何利用这个特性呢? 注意到下标的整体转移可以左移右移, 而 \\((3)\\) 式的分子就是整体转移, 于是考虑先整体转移再除以 \\(2\\) 的中间状态. 记 \\(tdp(i,v&#39;)=dp(i,v&#39;/2)\\), 这样 \\((3)\\) 式的状态转移就可以写成: \\[ dp(i,v&#39;)\\stackrel{+}\\longrightarrow \\begin{cases} \\displaystyle tdp\\left(i+1,v&#39;+A_j\\right)&amp;j=1,2,\\cdots,k&amp;N[i]=1\\\\ \\displaystyle tdp\\left(i+1,v&#39;\\right)&amp;&amp;N[i]=0 \\end{cases}\\tag3 \\] \\[ tdp(i+1,v&#39;)\\stackrel{+}\\longrightarrow dp\\left(i+1,\\flor{\\frac{v&#39;}2}\\right)\\quad v&#39;[0]=S[i] \\] \\[ dp(i+1,v&#39;)=tdp(i+1,2v&#39;+S[i])\\tag4 \\] \\((3)\\) 式的转移可以通过右移, 进行整体转移, 这一步是 \\(O(k\\bar A)\\) 的, 但是获得了 \\(1/64\\) 的常数. \\((4)\\) 式的转移可以直接每一位计算, 这一步是 \\(O(\\bar A)\\) 的. 于是整体复杂度获得了 \\(1/64\\) 的常数, 速度加快了. 注意: \\(dp\\) 的 \\(v&#39;\\le\\bar A\\), 于是中间状态 \\(tdp\\) 的 \\(v&#39;\\le2\\bar A\\). bitset 类的长度应该为 \\(2\\bar A\\). 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int as[210], ck[64], cks[64];const int mxn = 2.05e5;bitset&lt;mxn&gt; dp[64], tdp;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; ll n, s, k; cin &gt;&gt; n &gt;&gt; s &gt;&gt; k; for (int i = 0; i &lt; k; ++i) cin &gt;&gt; as[i]; for (ll i = 0; i &lt; 63; ++i) if ((n &gt;&gt; i) &amp; 1ll) ck[i] = 1; for (ll i = 0; i &lt; 63; ++i) if ((s &gt;&gt; i) &amp; 1ll) cks[i] = 1; dp[0].set(0); int frm; for (int i = 0; i &lt;= 62; ++i) &#123; if (ck[i]) for (int j = 0; j &lt; k; ++j) tdp ^= (dp[i] &lt;&lt; as[j]); else tdp = dp[i]; for (int kp = cks[i]; kp &lt; mxn; kp += 2) dp[i + 1][kp &gt;&gt; 1] = tdp[kp]; tdp.reset(); &#125; cout &lt;&lt; dp[63][0] &lt;&lt; \"\\n\"; for (int i = 0; i &lt; 64; ++i) dp[i].reset(); memset(ck, 0, sizeof(ck)); memset(cks, 0, sizeof(cks)); &#125; return 0;&#125; 花絮 二进制优化的题目很多, 我的思路来自 XJTUOJ-1046 mob的科学麻将, 这也是一道经典的二进制优化的题目. 题目链接: https://oj.skyair.org/problem/1046. 本题的题解可以见本人编写的《小学期实录》第91页. 这道题调了许多时间, 少任意一个优化, 或者数组开小了, 都会造成 Wrong Answer 或者 Time Limit Exceeded.","categories":[{"name":"2020 校队夏季训练","slug":"2020-校队夏季训练","permalink":"https://sheauhawjang.github.io/categories/2020-%E6%A0%A1%E9%98%9F%E5%A4%8F%E5%AD%A3%E8%AE%AD%E7%BB%83/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sheauhawjang.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sheauhawjang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包","slug":"背包","permalink":"https://sheauhawjang.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"bitset","slug":"bitset","permalink":"https://sheauhawjang.github.io/tags/bitset/"}]},{"title":"2020 小学期 Day7F 题解","slug":"2020 Microterm 1-7F","date":"2020-08-20T14:51:30.000Z","updated":"2020-08-21T14:20:01.000Z","comments":true,"path":"2020/08/20/2020 Microterm 1-7F/","link":"","permalink":"https://sheauhawjang.github.io/2020/08/20/2020%20Microterm%201-7F/","excerpt":"题目来源: Educational Codeforces Round 85: E. Divisor Paths 题目链接: https://codeforces.com/contest/1334/problem/E 题目来源: XJTUOJ-1167 zxh的高考幸运法阵 题目链接: https://oj.skyair.org/problem/1167 题面 给定一个正整数 \\(D\\), 根据如下规则构造一个图 \\(\\mathfrak D\\): \\(\\mathfrak D\\) 的每一个节点都是 \\(D\\) 的一个正因数. \\(\\mathfrak D\\) 的两个节点 \\(x,y\\) 如果满足: \\(x&gt;y\\), \\(y\\mid x\\) 且 \\(x/y\\) 是素数, 那么 \\(\\mathfrak D\\) 上就会有一个 \\(x,y\\) 之间的无向边, 边权为 \\(d(x)-d(y)\\). 其中 \\(d\\) 是除数函数, 表示因子个数. 现在有 \\(q\\) 次询问, 每次询问 \\(\\mathfrak D\\) 中两个节点 \\(u,v\\) 之间的最短路的个数 \\(N(u,v)\\), 输出对 \\(p\\) 取模后的结果. 备注 在 Codeforces 中的题目 \\(p=998244353\\). 在 XJTUOJ 中的题目 \\(p=919260817\\). 注意, \\(919260817\\) 是一个质数. 数据范围 \\[ 1\\le D\\le 10^{15} \\] \\[ 1\\le q\\le3\\cdot10^5 \\] \\[ 1\\le u,v\\le D \\]","text":"题目来源: Educational Codeforces Round 85: E. Divisor Paths 题目链接: https://codeforces.com/contest/1334/problem/E 题目来源: XJTUOJ-1167 zxh的高考幸运法阵 题目链接: https://oj.skyair.org/problem/1167 题面 给定一个正整数 \\(D\\), 根据如下规则构造一个图 \\(\\mathfrak D\\): \\(\\mathfrak D\\) 的每一个节点都是 \\(D\\) 的一个正因数. \\(\\mathfrak D\\) 的两个节点 \\(x,y\\) 如果满足: \\(x&gt;y\\), \\(y\\mid x\\) 且 \\(x/y\\) 是素数, 那么 \\(\\mathfrak D\\) 上就会有一个 \\(x,y\\) 之间的无向边, 边权为 \\(d(x)-d(y)\\). 其中 \\(d\\) 是除数函数, 表示因子个数. 现在有 \\(q\\) 次询问, 每次询问 \\(\\mathfrak D\\) 中两个节点 \\(u,v\\) 之间的最短路的个数 \\(N(u,v)\\), 输出对 \\(p\\) 取模后的结果. 备注 在 Codeforces 中的题目 \\(p=998244353\\). 在 XJTUOJ 中的题目 \\(p=919260817\\). 注意, \\(919260817\\) 是一个质数. 数据范围 \\[ 1\\le D\\le 10^{15} \\] \\[ 1\\le q\\le3\\cdot10^5 \\] \\[ 1\\le u,v\\le D \\] 题解 记 \\(S(x)\\) 为 \\(x\\) 的因子构成的集合. 考虑在 \\(\\mathfrak D\\) 边上行走的效果: 设 \\(u,v\\) 之间连接了一条边, \\(u&gt;v\\): 从 \\(v\\) 到 \\(u\\) 是 “向上走”, 编号乘上了一个素数, \\(S\\) 增加了一些因子, 边权就是 \\(S\\) 增加的因子数; 从 \\(u\\) 到 \\(v\\) 是 “向下走”, 编号除以了一个素数, \\(S\\) 减少了一些因子, 边权就是 \\(S\\) 减少的因子数. 考虑整除的情形: 即 \\(x\\) 走到 \\(y\\) 的过程, 其中 \\(x\\mid y\\). 这样至少要增加 \\(d(y)-d(x)\\) 个因子. 这时, 最理想的情况就是只增加因子, 不减少因子, 这样的路径长度就是 \\(d(y)-d(x)\\). 不断地向上走, 不断地乘上一个素数, 直到节点到达 \\(y\\), 这样的路径就是一条最短路. 设 \\(y/x=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_s^{\\alpha_s}\\), 则一条最短路需要乘 \\(\\alpha_1\\) 次 \\(p_1\\), 乘 \\(\\alpha_2\\) 次 \\(p_2\\), \\(\\cdots\\), 乘 \\(\\alpha_s\\) 次 \\(p_s\\). 乘素数的顺序不同, 所代表的最短路也不同. 依组合数学, 一共有 \\[ \\frac{\\left(\\displaystyle\\sum_{i=1}^s\\alpha_i\\right)!}{\\displaystyle\\prod_{i=1}^s\\alpha_i!}=\\frac{(\\alpha_1+\\alpha_2+\\cdots+\\alpha_s)!}{\\alpha_1!\\alpha_2!\\cdots\\alpha_s!}=N(x,y)\\tag1 \\] 种排列方式, 这就是这种情形的答案. 对于不整除的情形, 我们需要分别乘一些素数和除以一些素数. 乘和除的顺序是怎样的? 应该是先尽可能地向下走, 再向上走. 即, 先从 \\(x\\) 走到 \\(\\gcd(x,y)\\), 之后再从 \\(\\gcd(x,y)\\) 走到 \\(y\\). 这是因为, 向下走会减少之后每一步向上走的时候增加的因子数目, 同时避免向上走导致的向下走删除的因子数目的增多. 这两步走法都是整除的情形, 可以用公式 \\((1)\\) 计算. 由乘法原理, 走法数就是这两步走法数的乘积, 即 \\[ N(x,y)=N(\\gcd(x,y),x)\\cdot N(\\gcd(x,y),y) \\] 综上所述: \\[ N(x,y)=\\begin{cases} \\displaystyle\\frac{(\\alpha_1+\\alpha_2+\\cdots+\\alpha_s)!}{\\alpha_1!\\alpha_2!\\cdots\\alpha_s!}&amp;x\\mid y&amp;\\displaystyle \\frac yx=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_s^{\\alpha_s}\\\\ N(\\gcd(x,y),x)\\cdot N(\\gcd(x,y),y)&amp;x\\nmid y \\end{cases} \\] 在算法实现上, 阶乘可以预处理, 算出 \\(y/x\\) 的标准分解式即可直接得到答案. 由于 \\(x,y,y/x\\) 都是 \\(D\\) 的因子, 标准分解式中的质数一定是 \\(D\\) 的质因子, 而 \\(D\\) 的质因子最多有 \\(\\log D\\) 个, 于是可以预处理 \\(D\\) 的所有质因子, 然后计算标准分解式时, 计算每个质因子的指数即可. 分解复杂度为 \\(O(\\log D)\\), 计算复杂度为 \\(O(\\log D)\\). 总时间复杂度为 \\(O(q\\log D)\\). 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;class llp; // 见我的模板vector&lt;ll&gt; ps;map&lt;ll, int&gt; cnt;const int mx = 1e5;llp pows[mx], invs[mx];void dvd(ll d)&#123; for (ll p = 2; p * p &lt;= d; ++p) if (d % p == 0) &#123; ps.push_back(p); do d /= p; while (d % p == 0); &#125; if (d != 1) ps.push_back(d);&#125;ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a; &#125;llp solve(ll u, ll v)&#123; if (u == v) return 1; if (u &gt; v) swap(u, v); if (v % u != 0) return solve(gcd(u, v), u) * solve(gcd(u, v), v); cnt.clear(); ll up = v / u; ll tcnt = 0; for (ll p : ps) while (up % p == 0) up /= p, ++cnt[p], ++tcnt; llp ans = pows[tcnt]; for (auto x : cnt) ans *= invs[x.second]; return ans;&#125;int main()&#123; pows[0] = 1; for (int i = 1; i &lt; mx; ++i) pows[i] = pows[i - 1] * i; invs[mx - 1] = ~pows[mx - 1]; for (int i = mx - 2; i &gt;= 0; --i) invs[i] = invs[i + 1] * (i + 1); ll d; scanf(\"%lld\", &amp;d); dvd(d); int q; scanf(\"%d\", &amp;q); for (int t = 0; t &lt; q; ++t) &#123; ll v, u; scanf(\"%lld%lld\", &amp;u, &amp;v); printf(\"%d\\n\", (int)solve(v, u)); &#125; return 0;&#125;","categories":[{"name":"2020 小学期","slug":"2020-小学期","permalink":"https://sheauhawjang.github.io/categories/2020-%E5%B0%8F%E5%AD%A6%E6%9C%9F/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"https://sheauhawjang.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sheauhawjang.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"2020 小学期第一期 Day7G 题解","slug":"2020 Microterm 1-7G","date":"2020-08-19T04:33:50.000Z","updated":"2020-08-20T14:55:49.000Z","comments":true,"path":"2020/08/19/2020 Microterm 1-7G/","link":"","permalink":"https://sheauhawjang.github.io/2020/08/19/2020%20Microterm%201-7G/","excerpt":"题目来源: XJTUOJ-1168 zxh的后宫管理系统 题目链接: https://oj.skyair.org/problem/1168 题面 一共 \\(T\\) 组数据. 现有一个未知的整数 \\(k\\), 满足 \\(1\\le k\\le n\\). 现在你被宣称 \\(k\\) 的值等于 \\(x\\), 但是你不知道真假. 你现在可以提交一个任意大的正整数 \\(y\\), 之后获得返回值 \\(\\gcd(k,y)\\). 你需要寻找一个合适的 \\(y\\), 使得你可以通过返回值来查验 \\(x\\) 和 \\(k\\) 是否相等. 如果有很多满足条件的值, 选阿泽最小的那个. 如果没有合适的 \\(y\\), 输出 \\(-1\\). 由于 \\(y\\) 很大, 输出对 \\(920011128\\) 取模后的结果. 简要描述 给定 \\(n, x\\), 试给出一个最小的 \\(y\\), 使得 \\(\\forall 1\\le a\\le n\\), 若 \\(a\\ne x\\), 则 \\(\\gcd(a,y)\\ne \\gcd(x,y)\\). 由于 \\(y\\) 很大, 输出对 \\(920011128\\) 取模后的结果. 数据范围 \\[ 1\\le T&lt;10 \\] \\[ 1\\le k\\le n\\le10^7 \\]","text":"题目来源: XJTUOJ-1168 zxh的后宫管理系统 题目链接: https://oj.skyair.org/problem/1168 题面 一共 \\(T\\) 组数据. 现有一个未知的整数 \\(k\\), 满足 \\(1\\le k\\le n\\). 现在你被宣称 \\(k\\) 的值等于 \\(x\\), 但是你不知道真假. 你现在可以提交一个任意大的正整数 \\(y\\), 之后获得返回值 \\(\\gcd(k,y)\\). 你需要寻找一个合适的 \\(y\\), 使得你可以通过返回值来查验 \\(x\\) 和 \\(k\\) 是否相等. 如果有很多满足条件的值, 选阿泽最小的那个. 如果没有合适的 \\(y\\), 输出 \\(-1\\). 由于 \\(y\\) 很大, 输出对 \\(920011128\\) 取模后的结果. 简要描述 给定 \\(n, x\\), 试给出一个最小的 \\(y\\), 使得 \\(\\forall 1\\le a\\le n\\), 若 \\(a\\ne x\\), 则 \\(\\gcd(a,y)\\ne \\gcd(x,y)\\). 由于 \\(y\\) 很大, 输出对 \\(920011128\\) 取模后的结果. 数据范围 \\[ 1\\le T&lt;10 \\] \\[ 1\\le k\\le n\\le10^7 \\] 题解 答案为 \\[ y=x\\prod_{p\\le n/x}p \\] 证明见 2020 CCPC Wannafly 冬令营 Day1H 题解. 采用线性筛预处理 \\([1,10^7]\\) 中的所有素数. 若每次询问暴力计算素数乘积, 则复杂度为 \\(O(Tn)\\). 若采用前缀积, 则复杂度为 \\(O(T+n)\\). 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e7 + 5;const int p = 920011128;vector&lt;int&gt; ps; // 所有素数bool chk[maxn]; // 合数为truell psum[maxn];void fillPrime(int rge)&#123; for (int i = 2; i &lt;= rge; i++) &#123; if (!chk[i]) ps.push_back(i); for (int j = 0; j &lt; ps.size() &amp;&amp; ps[j] &lt;= rge / i; j++) &#123; chk[i * ps[j]] = true; if (i % ps[j] == 0) break; &#125; &#125;&#125;int main()&#123; const int rge = 1e7 + 3; fillPrime(rge); psum[0] = psum[1] = 1; for (int i = 2; i &lt;= rge; ++i) if (chk[i]) psum[i] = psum[i - 1]; else psum[i] = psum[i - 1] * i % p; int t; cin &gt;&gt; t; for (int tt = 0; tt &lt; t; ++tt) &#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; k * psum[n / k] % p &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"2020 小学期","slug":"2020-小学期","permalink":"https://sheauhawjang.github.io/categories/2020-%E5%B0%8F%E5%AD%A6%E6%9C%9F/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"构造","slug":"构造","permalink":"https://sheauhawjang.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"2020 CCPC Wannafly 冬令营 Day1H 题解","slug":"2020 Wannafly Winter 1H","date":"2020-08-18T12:11:01.000Z","updated":"2020-08-19T15:50:44.000Z","comments":true,"path":"2020/08/18/2020 Wannafly Winter 1H/","link":"","permalink":"https://sheauhawjang.github.io/2020/08/18/2020%20Wannafly%20Winter%201H/","excerpt":"题面 一共 \\(T\\) 组数据. 现有一个未知的整数 \\(k\\), 满足 \\(1\\le k\\le n\\). 现在你被宣称 \\(k\\) 的值等于 \\(x\\), 但是你不知道真假. 你现在可以提交一个任意大的正整数 \\(y\\), 之后获得返回值 \\(\\gcd(k,y)\\). 你需要输出一个合适的 \\(y\\), 使得你可以通过返回值来查验 \\(x\\) 和 \\(k\\) 是否相等. 如果有很多满足条件的值, 输出最小的那个. 如果没有合适的 \\(y\\), 输出 \\(-1\\). 简要描述 给定 \\(n, x\\), 试给出一个最小 \\(y\\), 使得 \\(\\forall 1\\le a\\le n\\), 若 \\(a\\ne x\\), 则 \\(\\gcd(a,y)\\ne \\gcd(x,y)\\). 数据范围 \\[ 1\\le T\\le 50 \\] \\[ 1\\le k\\le n\\le500 \\]","text":"题面 一共 \\(T\\) 组数据. 现有一个未知的整数 \\(k\\), 满足 \\(1\\le k\\le n\\). 现在你被宣称 \\(k\\) 的值等于 \\(x\\), 但是你不知道真假. 你现在可以提交一个任意大的正整数 \\(y\\), 之后获得返回值 \\(\\gcd(k,y)\\). 你需要输出一个合适的 \\(y\\), 使得你可以通过返回值来查验 \\(x\\) 和 \\(k\\) 是否相等. 如果有很多满足条件的值, 输出最小的那个. 如果没有合适的 \\(y\\), 输出 \\(-1\\). 简要描述 给定 \\(n, x\\), 试给出一个最小 \\(y\\), 使得 \\(\\forall 1\\le a\\le n\\), 若 \\(a\\ne x\\), 则 \\(\\gcd(a,y)\\ne \\gcd(x,y)\\). 数据范围 \\[ 1\\le T\\le 50 \\] \\[ 1\\le k\\le n\\le500 \\] 题解 注意到 \\(\\gcd(x,y)=\\gcd(\\gcd(x,y),y)\\), 于是应满足 \\(\\gcd(x,y)=x\\), 即 \\(x\\mid y\\). 设 \\(y=xy&#39;\\). 若 \\(x\\nmid a\\), 则显然 \\(\\gcd(a,y)\\ne x\\). \\(\\forall a&#39;\\in(1,n/x]\\), 都有 \\(\\gcd(a&#39;x,y)=x\\gcd(a&#39;,y&#39;)\\), 于是此时 \\(\\gcd(a&#39;,y&#39;)\\ne 1\\). 考虑到: 对于任意 \\((1,n/x]\\) 中的素数 \\(p\\), 亦都应该有 \\(\\gcd(p,y&#39;)\\ne 1\\), 此时有 \\(\\gcd(p,y&#39;)=p\\), \\(p\\mid y&#39;\\). 于是这些素数的乘积 \\(P\\) 满足 \\(P\\mid y&#39;\\). \\(P\\le y&#39;\\). 若 \\(P=y&#39;\\), 则 \\(\\forall a&#39;\\in (1,n/x]\\), \\(a&#39;\\) 的任意素因子 \\(p\\) 一定满足 \\(1&lt;p\\le a&#39;\\le n/x\\), \\(p\\mid y\\), 于是 \\(\\gcd(a&#39;,y&#39;)\\ne 1\\), \\(\\gcd(a&#39;x,y)\\ne x\\). 于是取 \\(P=y&#39;\\) 是可行的, 而且是最小的解. 预处理 \\([1,500]\\) 中的所有素数, 解就是 \\[ y=x\\prod_{p\\le n/x}p \\] 由于 \\(y\\) 的可能的最大值超过了 \\(2^{128}\\), 于是应该使用高精度乘法, 或者使用 Python. 忽略高精度乘法的复杂度常数. 若每次询问暴力计算素数乘积, 则复杂度为 \\(O(Tn)\\). 若采用前缀积, 则复杂度为 \\(O(T+n)\\). 代码实现 1234567891011121314prime = [2,3,5,7,11,13,17,19,...,599] # 600以内的素数请自己打表补全, 这里省略.ts = 0hds = [1]for i in range (1, 600): if (prime[ts] == i): hds.append(int(prime[ts] * hds[i - 1])) ts += 1 else: hds.append(hds[i - 1])t = int(input())for rt in range (0, t): n, k = map(int, input().split(' ')) print(k * hds[n // k])","categories":[{"name":"2020 CCPC WannaFly 冬令营","slug":"2020-CCPC-WannaFly-冬令营","permalink":"https://sheauhawjang.github.io/categories/2020-CCPC-WannaFly-%E5%86%AC%E4%BB%A4%E8%90%A5/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"构造","slug":"构造","permalink":"https://sheauhawjang.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"高精度","slug":"高精度","permalink":"https://sheauhawjang.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"模 p 同余类模板","slug":"Modulo p Module","date":"2020-08-14T13:00:23.000Z","updated":"2020-08-14T14:14:08.000Z","comments":true,"path":"2020/08/14/Modulo p Module/","link":"","permalink":"https://sheauhawjang.github.io/2020/08/14/Modulo%20p%20Module/","excerpt":"该模板为作者原创. 问题引入 请输出对 \\(p\\) 取模后的结果. 请输出模 \\(p\\) 意义下的结果. 最终答案可以表示为 \\(a/b\\), 请输出 \\(a\\cdot b^{-1}\\bmod p\\), 其中 \\(b^{-1}\\) 是 \\(b\\) 对模 \\(p\\) 的乘法逆元. 在我们做题的时候, 经常会遇到输出在模 \\(p\\) 意义下的结果的题目. 上面三种是经典的这种要求的说法.","text":"该模板为作者原创. 问题引入 请输出对 \\(p\\) 取模后的结果. 请输出模 \\(p\\) 意义下的结果. 最终答案可以表示为 \\(a/b\\), 请输出 \\(a\\cdot b^{-1}\\bmod p\\), 其中 \\(b^{-1}\\) 是 \\(b\\) 对模 \\(p\\) 的乘法逆元. 在我们做题的时候, 经常会遇到输出在模 \\(p\\) 意义下的结果的题目. 上面三种是经典的这种要求的说法. 传统做法 这种题目在计算的过程中, 需要用到大量的取模运算. 原则上, 每进行一次加减乘除的运算, 都需要进行至少一次取模. 在读入一个变量后, 也应该立即进行至少一次取模. 如果结果产生了负数, 则可能需要再进行一次取模来避免这种情况的发生. 例如: 计算 \\((a+b)\\bmod p\\). \\(-2^{63}&lt;a,b&lt;2^{63}\\), \\(1&lt;p&lt;2^{62}\\). 123456789#include&lt;stdio.h&gt;typedef long long ll;int main()&#123; ll a, b, p; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;p); printf(\"%lld\", ((a % p + b % p) % p + p) % p); return 0;&#125; 注意到, 这个简单的程序进行了 4 次了取模. 这样产生了一些问题: 在这个程序中, 每一步取模都是缺一不可的. 对 \\(a,b\\) 的取模是防止 \\(a+b\\) 过大; 对和取模是题目要求; 最后对取模后的结果在加上一个 \\(p\\) 后取模是为了防止直接取模得到负数. 上述四个取模缺少任意一个没有替代品的取模, 都会导致答案的错误. 而在做题的过程中, 上述的取模运算或替代品都是机械化而重复的, 有代码复用的可能; 同时, 这些运算缺一不可, 而在赛场考场上做题时, 在大面积的取模过程中, 可能一时疏忽漏掉某个取模, 导致算法正确的程序出现 Wrong Answer 的情况, 这种错误又很难查验, 因此高效便捷的代码复用很有必要. 而且, 取模运算速度较慢, 应该减少模运算的使用: 在某些情况下利用 if-else 结构或三目运算符 ?: 来作为直接偷懒使用取模符号的替代品. 然而, 这些替代品虽然增加了效率, 但是却让代码更加反直觉, 编写更为复杂, 大量重复出现不利于赛场考场的应用. 代码复用就可以令这些问题迎刃而解. 代码实现 题面固定模数 \\(p\\) 情况的实现, 这也是最常见的一种情况. 如果 \\(p\\) 是通过键盘输入, 且对于一组数据, 输入后不再改变, 则只需将类声明中的 static const int 类型的常量的声明作为全程序的全局变量即可. 但是对变量取模会显著地比对常量取模更慢. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, n) for (int i = 0; i &lt; n; ++i)typedef long long ll;class llp&#123; int v; template &lt;class T&gt; llp(T a, int) &#123; v = a; &#125;public: static const int p = 998244353; static const int phi = p - 1; static const int invp = phi - 1; llp() &#123; v = 0; &#125; template &lt;class T&gt; static T mod(T a) &#123; return a %= p, a &gt;= 0 ? a : a + p; &#125; template &lt;class T&gt; static T &amp;opmod(T &amp;a) &#123; return a = mod(a); &#125; template &lt;class T&gt; llp(T a) &#123; v = mod(a); &#125; template &lt;class T&gt; explicit operator T() const &#123; return v; &#125; int operator*() const &#123; return v; &#125; int *operator&amp;() const &#123; return (int *)&amp;v; &#125; friend istream &amp;operator&gt;&gt;(istream &amp;ipt, llp &amp;x) &#123; return ipt &gt;&gt; x.v, opmod(x.v), ipt; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;opt, llp x) &#123; return opt &lt;&lt; x.v; &#125; llp operator+(llp b) const &#123; return v + b.v &gt;= p ? llp(v + b.v - p, 0) : llp(v + b.v, 0); &#125; friend llp operator+(ll a, llp b) &#123; return b + a; &#125; llp &amp;operator+=(llp b) &#123; return v += b.v, v = v &gt;= p ? v - p : v, *this; &#125; llp &amp;operator++() &#123; return *this += 1; &#125; llp operator++(int) &#123; return ++*this, *this - 1; &#125; llp operator-() const &#123; return v ? llp(p - v, 0) : llp(); &#125; llp operator-(llp b) const &#123; return *this + (-b); &#125; friend llp operator-(ll a, llp b) &#123; return -b + a; &#125; llp &amp;operator-=(llp b) &#123; return *this += -b; &#125; llp &amp;operator--() &#123; return *this -= 1; &#125; llp operator--(int) &#123; return --*this, *this + 1; &#125; llp operator*(llp b) const &#123; return ll(v) * b.v; &#125; friend llp operator*(ll a, llp b) &#123; return b * a; &#125; llp &amp;operator*=(llp b) &#123; return *this = *this * b; &#125; llp operator[](ll b) const &#123; llp ans = 1, a = *this; while (b) &#123; if (b &amp; 1) ans *= a; a *= a, b &gt;&gt;= 1; &#125; return ans; &#125; llp operator^(ll b) const &#123; return (*this)[b]; &#125; llp &amp;operator^=(ll b) &#123; return *this = *this ^ b; &#125; llp operator~() const &#123; return *this ^ invp; &#125; llp operator/(llp b) const &#123; return *this * ~b; &#125; friend llp operator/(ll a, llp b) &#123; return (~b) * a; &#125; llp &amp;operator/=(llp b) &#123; return *this = *this / b; &#125; llp operator&lt;&lt;(int b) const &#123; return *this * llp(2)[b]; &#125; llp &amp;operator&lt;&lt;=(int b) &#123; return *this = *this &lt;&lt; b; &#125; llp operator&gt;&gt;(int b) const &#123; return *this / llp(2)[b]; &#125; llp &amp;operator&gt;&gt;=(int b) &#123; return *this = *this &gt;&gt; b; &#125; bool operator==(ll b) const &#123; return mod(b) == v; &#125; bool operator==(llp b) const &#123; return v == b.v; &#125; bool operator!=(ll b) const &#123; return !(*this == b); &#125; bool operator!=(llp b) const &#123; return !(*this == b); &#125; bool operator&lt;(llp b) const &#123; return v &lt; b.v; &#125; bool operator&lt;=(llp b) const &#123; return v &lt;= b.v; &#125; bool operator&gt;(llp b) const &#123; return v &gt; b.v; &#125; bool operator&gt;=(llp b) const &#123; return v &gt;= b.v; &#125; friend llp operator&lt;(ll a, llp b) &#123; return b &gt; a; &#125; friend llp operator&lt;=(ll a, llp b) &#123; return b &gt;= a; &#125; friend llp operator&gt;(ll a, llp b) &#123; return b &lt; a; &#125; friend llp operator&gt;=(ll a, llp b) &#123; return b &lt;= a; &#125; int var() const &#123; return v; &#125; int mod() const &#123; return p; &#125; llp sqd() const &#123; return *this * *this; &#125; llp inv() const &#123; return ~*this; &#125; llp pow(ll b) const &#123; return *this ^ b; &#125;&#125;;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原创","slug":"原创","permalink":"https://sheauhawjang.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"模板","slug":"模板","permalink":"https://sheauhawjang.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"数学分析读书报告(2020年春)","slug":"Mathematical Analysis Reading Report 2020 Spring","date":"2020-04-29T11:17:15.000Z","updated":"2020-04-30T14:01:32.000Z","comments":true,"path":"2020/04/29/Mathematical Analysis Reading Report 2020 Spring/","link":"","permalink":"https://sheauhawjang.github.io/2020/04/29/Mathematical%20Analysis%20Reading%20Report%202020%20Spring/","excerpt":"\\[ \\newcommand{\\isum}[2]{\\sum\\limits_{ #2 = #1 }^{\\infty}} \\newcommand{\\iprod}[2]{\\prod\\limits_{ #2 = #1 }^{\\infty}} \\newcommand{\\lsum}[3]{\\sum\\limits_{ #2 = #1 }^{ #3 }} \\newcommand{\\lprod}[3]{\\prod\\limits_{ #2 = #1 }^{ #3 }} \\newcommand{\\llim}[2]{\\lim\\limits_{ #1 \\rightarrow #2 }} \\newcommand{\\brac}[1]{\\left( #1 \\right)} \\newcommand{\\lrac}[1]{\\left\\{ #1 \\right\\}} \\newcommand{\\flor}[1]{\\left\\lfloor #1 \\right\\rfloor} \\newcommand{\\ceil}[1]{\\left\\lceil #1 \\right\\rceil} \\newcommand{\\agle}[1]{\\left\\langle #1 \\right\\rangle} \\newcommand{\\abs}[1]{\\left| #1 \\right|} \\newcommand{\\abss}[1]{\\left\\| #1 \\right\\|} \\newcommand{\\id}[1]{\\text{( #1 ) }} \\newcommand{\\mathbs}[1]{\\boldsymbol{ #1 }} \\newcommand{\\mvec}[1]{\\overrightarrow{ #1 }} \\newcommand{\\mbar}[1]{\\overline{ #1 }} \\newcommand{\\bigf}{\\displaystyle} \\newcommand{\\dif}{\\mathrm{d}} \\newcommand{\\ddif}[1]{\\frac{\\dif}{\\dif #1 }} \\newcommand{\\cddif}[1]{\\cfrac{\\dif}{\\dif #1 }} \\newcommand{\\eset}{\\varnothing} \\newcommand{\\sh}{\\mathrm{sh\\ }} \\newcommand{\\ch}{\\mathrm{ch\\ }} \\newcommand{\\Imm}{\\mathrm{Im\\ }} \\newcommand{\\Ker}{\\mathrm{Ker\\ }} \\newcommand{\\rank}{\\mathrm{rank\\ }} \\newcommand{\\diag}{\\mathrm{diag\\ }} \\newcommand{\\sgn}{\\mathrm{sgn\\ }} \\newcommand{\\simeqq}{\\cong} \\newcommand{\\tdeg}{^\\circ} \\newcommand{\\roku}{\\partial} \\newcommand{\\bksl}{\\backslash} \\newcommand{\\mrm}{\\mathrm} \\newcommand{\\mbb}{\\mathbb} \\newcommand{\\mbf}{\\mathbf} \\newcommand{\\mscr}{\\mathscr} \\newcommand{\\mbs}[1]{\\boldsymbol{ #1 }} \\newcommand{\\kaz}[1]{\\begin{cases} #1 \\end{cases}} \\newcommand{\\pmat}[1]{\\begin{pmatrix} #1 \\end{pmatrix}} \\text{数学分析读书报告(2020年春)} \\] 在第一学期的数学分析课程中, 我们定义了一整套实数系统. 当时我们先用皮亚诺公理和集合论两种方式定义了自然数集, 然后再用自然数对的商集定义了整数集, 用整数对的集定义了有理数集, 最后又用戴德金分割定义了实数. 然而最近读到了卓里奇的《数学分析》, 在这本书里, 作者用了另一种方式定义了这一套系统: 先给出实数集的公理系统, 之后在逐步导出自然数集, 整数集和有理数集. 既然是从实数集开始, 那么作者是如何定义实数集的呢? 下面就是实数集的定义:","text":"\\[ \\newcommand{\\isum}[2]{\\sum\\limits_{ #2 = #1 }^{\\infty}} \\newcommand{\\iprod}[2]{\\prod\\limits_{ #2 = #1 }^{\\infty}} \\newcommand{\\lsum}[3]{\\sum\\limits_{ #2 = #1 }^{ #3 }} \\newcommand{\\lprod}[3]{\\prod\\limits_{ #2 = #1 }^{ #3 }} \\newcommand{\\llim}[2]{\\lim\\limits_{ #1 \\rightarrow #2 }} \\newcommand{\\brac}[1]{\\left( #1 \\right)} \\newcommand{\\lrac}[1]{\\left\\{ #1 \\right\\}} \\newcommand{\\flor}[1]{\\left\\lfloor #1 \\right\\rfloor} \\newcommand{\\ceil}[1]{\\left\\lceil #1 \\right\\rceil} \\newcommand{\\agle}[1]{\\left\\langle #1 \\right\\rangle} \\newcommand{\\abs}[1]{\\left| #1 \\right|} \\newcommand{\\abss}[1]{\\left\\| #1 \\right\\|} \\newcommand{\\id}[1]{\\text{( #1 ) }} \\newcommand{\\mathbs}[1]{\\boldsymbol{ #1 }} \\newcommand{\\mvec}[1]{\\overrightarrow{ #1 }} \\newcommand{\\mbar}[1]{\\overline{ #1 }} \\newcommand{\\bigf}{\\displaystyle} \\newcommand{\\dif}{\\mathrm{d}} \\newcommand{\\ddif}[1]{\\frac{\\dif}{\\dif #1 }} \\newcommand{\\cddif}[1]{\\cfrac{\\dif}{\\dif #1 }} \\newcommand{\\eset}{\\varnothing} \\newcommand{\\sh}{\\mathrm{sh\\ }} \\newcommand{\\ch}{\\mathrm{ch\\ }} \\newcommand{\\Imm}{\\mathrm{Im\\ }} \\newcommand{\\Ker}{\\mathrm{Ker\\ }} \\newcommand{\\rank}{\\mathrm{rank\\ }} \\newcommand{\\diag}{\\mathrm{diag\\ }} \\newcommand{\\sgn}{\\mathrm{sgn\\ }} \\newcommand{\\simeqq}{\\cong} \\newcommand{\\tdeg}{^\\circ} \\newcommand{\\roku}{\\partial} \\newcommand{\\bksl}{\\backslash} \\newcommand{\\mrm}{\\mathrm} \\newcommand{\\mbb}{\\mathbb} \\newcommand{\\mbf}{\\mathbf} \\newcommand{\\mscr}{\\mathscr} \\newcommand{\\mbs}[1]{\\boldsymbol{ #1 }} \\newcommand{\\kaz}[1]{\\begin{cases} #1 \\end{cases}} \\newcommand{\\pmat}[1]{\\begin{pmatrix} #1 \\end{pmatrix}} \\text{数学分析读书报告(2020年春)} \\] 在第一学期的数学分析课程中, 我们定义了一整套实数系统. 当时我们先用皮亚诺公理和集合论两种方式定义了自然数集, 然后再用自然数对的商集定义了整数集, 用整数对的集定义了有理数集, 最后又用戴德金分割定义了实数. 然而最近读到了卓里奇的《数学分析》, 在这本书里, 作者用了另一种方式定义了这一套系统: 先给出实数集的公理系统, 之后在逐步导出自然数集, 整数集和有理数集. 既然是从实数集开始, 那么作者是如何定义实数集的呢? 下面就是实数集的定义: 实数集 满足以下四组条件的集合 \\(\\mbb R\\) 叫做实数集, 其中的元素叫做实数, 这些条件构成了实数集的公理系统: 1. 加法公理 确定了一个映射(加法) \\[ +:\\mbb R\\times\\mbb R\\rightarrow\\mbb R \\] s.t. \\(\\mbb R\\) 中任意二元 \\(x,y\\) 之有序对 \\((x,y)\\) 都有某元素 \\(x+y\\in\\mbb R\\) 与之对应, 称 \\(x+y\\) 为 \\(x,y\\) 之和. 该映射亦满足以下条件: \\(1_+\\). 存在加法零元 \\(0\\) s.t. \\(\\forall x\\in\\mbb R\\) 都有 \\[ x+0=0+x=x \\] \\(2_+\\). \\(\\forall x\\in\\mbb R\\), 存在负元 \\(-x\\in\\mbb R\\) s.t. \\[ x+(-x)=(-x)+x=0 \\] \\(3_+\\). 运算 \\(+\\) 是结合的, 即 \\(\\forall x,y,z\\in\\mbb R\\) 满足 \\[ x+(y+z)=(x+y)+z \\] \\(4_+\\). 运算 \\(+\\) 是交换的, 即 \\(\\forall x,y\\in\\mbb R\\) 满足 \\[ x+y=y+x \\] 群 装备了满足上述 \\(1_+,2_+,3_+\\) 条件的运算的集合称为群. 如果这个运算叫加法, 那么这个群称为加群. 如果这个运算是交换的, 即满足条件 \\(4_+\\), 那么这个群称为交换群或 Abel 群. \\(\\mbb R\\) 关于加法运算是 Abel 群. 2. 乘法公理 确定了一个映射(乘法) \\[ \\bullet:\\mbb R\\times\\mbb R\\rightarrow\\mbb R \\] s.t. \\(\\mbb R\\) 中任意二元 \\(x,y\\) 之有序对 \\((x,y)\\) 都有某元素 \\(x\\cdot y\\in\\mbb R\\) 与之对应, 称 \\(x\\cdot y\\) 为 \\(x,y\\) 之积. 该映射亦满足以下条件: \\(1_\\bullet\\). 存在单位元 \\(1\\) s.t. \\(\\forall x\\in\\mbb R\\bksl0\\) 都有 \\[ x\\cdot1=1\\cdot x=x \\] \\(2_\\bullet\\). \\(\\forall x\\in\\mbb R\\bksl0\\), 存在逆元 \\(x^{-1}\\in\\mbb R\\bksl0\\) s.t. \\[ x\\cdot x^{-1}=x^{-1}\\cdot x=0 \\] \\(3_\\bullet\\). 运算 \\(\\bullet\\) 是结合的, 即 \\(\\forall x,y,z\\in\\mbb R\\) 满足 \\[ x\\cdot(y\\cdot z)=(x\\cdot y)\\cdot z \\] \\(4_\\bullet\\). 运算 \\(\\bullet\\) 是交换的, 即 \\(\\forall x,y\\in\\mbb R\\) 满足 \\[ x\\cdot y=y\\cdot x \\] \\(\\mbb R\\bksl0\\) 关于乘法运算是 Abel 群. 1-2. 加法与乘法 乘法对加法有分配性: \\(\\forall x,y,z\\in\\mbb R\\), \\[ (x+y)\\cdot z=x\\cdot z+y\\cdot z \\] 由于乘法是交换的, 左分配律亦成立. 域 若一个集合上定义了两种运算, 它们满足上述的所有公理, 就称这个集合为一个代数域, 简称域. 3. 序公理 \\(\\mbb R\\) 的元素间有不等关系 \\(\\le\\), 对 \\(\\mbb R\\) 的元素 \\(x,y\\), 或满足 \\(x\\le y\\), 或不满足 \\(x\\le y\\). 同时还满足以下条件: \\(0_\\le\\). \\(\\forall x\\in\\mbb R\\), \\(x\\le x\\). (反身性) \\(1_\\le\\). 若 \\(x\\le y\\) 且 \\(y\\le x\\), 则 \\(x=y\\). (反对称性) \\(2_\\le\\). 若 \\(x\\le y\\) 且 \\(y\\le z\\), 则 \\(x\\le z\\). (传递性) \\(3_\\le\\). \\(\\forall x,y\\in\\mbb R\\), \\(x\\le y\\) 或 \\(y\\le x\\). 序 如果某个集合的某些元素间有满足公理 \\(0_\\le,1_\\le,2_\\le\\) 的二元关系, 就称该集合为偏序集. 若偏序集满足 \\(3_\\le\\), 即任意两个元素间均有这种关系, 就称此集合为线性序集.（个人更喜欢全序集 [2]这个名字） \\(\\mbb R\\) 关于不等关系是全序集. 1-3. 加法与序 \\(\\forall x,y,z\\in\\mbb R\\), 若 \\(x\\le y\\), 则 \\(x+z\\le y+z\\). 2-3. 乘法与序 \\(\\forall x,y\\in\\mbb R\\),若 \\(0\\le x\\) 且 \\(0\\le y\\), 则 \\(0\\le x\\cdot y\\). 4. 完备公理 若 \\(X,Y\\) 是 \\(\\mbb R\\) 的非空子集, 且有性质: 若 \\(\\forall x\\in X,y\\in Y\\), 都有 \\(x\\le y\\); 那么 \\(\\exists c\\in\\mbb R\\), s.t. \\(\\forall x\\in X,y\\in Y\\) 都有 \\(x\\le c\\le y\\). 以上便是实数集的公理系统了. 有了这套公理系统, 就构造出了一个抽象系统. 但是, 类似皮亚诺公理存在的问题一样, 书中也提出了两个问题: 无矛盾性: 这套公理是否相容? 是否真的存在满足上述公理系统的集合? 范畴性: 这组公理确定的数学对象是否唯一? 任意两个不同的实现是否同构? 关于无矛盾性的问题, 书中用集合论公理系统出发建立自然数集, 然后是有理数集, 最后是是实数集的描述来证明的. 感觉起来像是我们之前学习的那一种方式. 范畴性的问题似乎是构造两个实数模型 \\(\\mbb R\\) 到 \\(\\mbb R&#39;\\) 的同构映射, 但是我想不到比较合适的方法定义这个映射. 下面是实数的一些代数性质. 书中对部分定理进行了证明. 由于证明很简单, 这里不做赘述. 加法公理的推论 \\(1\\tdeg\\) 实数集中有唯一的零元. \\(2\\tdeg\\) 实数集中每个元素有唯一的负元. \\(3\\tdeg\\) 方程 \\(a+x=b\\) 在 \\(\\mbb R\\) 中有唯一解 \\(x=b+(-a)\\) (通常表示为 \\(b-a\\)). 乘法公理的推论 \\(1\\tdeg\\) 实数集中有唯一的单位元. \\(2\\tdeg\\) 实数集中每个 \\(x\\ne0\\), 有唯一的逆元 \\(x^{-1}\\). \\(3\\tdeg\\) 方程 \\(a\\cdot x=b\\), 当 \\(a\\in\\mbb R\\bksl0\\) 时, 有唯一解 \\(x=b\\cdot a^{-1}\\). 加法与乘法的推论 \\(1\\tdeg\\) \\(\\forall x\\in\\mbb R\\), \\(x\\cdot0=0\\cdot x=0\\). \\(2\\tdeg\\) 若 \\(x\\cdot y=0\\), 则 \\(x=0\\) 或 \\(y=0\\). \\(3\\tdeg\\) \\(\\forall x\\in\\mbb R\\), \\(-x=(-1)\\cdot x\\). \\(4\\tdeg\\) \\(\\forall x\\in\\mbb R\\), \\((-1)\\cdot(-x)=x\\). \\(3\\tdeg\\) \\(\\forall x\\in\\mbb R\\), \\((-x)\\cdot(-x)=x\\cdot x\\). 序公理的推论 定义 \\(x\\le y\\) 可以写作 \\(y\\ge x\\). \\(x\\ne y\\) 时, \\(x\\le y\\) 可以写成 \\(x&lt;y\\) 或 \\(y&gt;x\\), 此时称之为严格不等式. \\(1\\tdeg\\) \\(\\forall x,y\\in\\mbb R\\), \\[ x&lt;y,x=y,x&gt;y \\] 恰有一种关系成立. \\(2\\tdeg\\) \\(\\forall x,y,z\\in\\mbb R\\): 若 \\(x&lt;y\\) 且 \\(y\\le z\\), 则 \\(x&lt;z\\); 若 \\(x\\le y\\) 且 \\(y&lt;z\\), 则 \\(x&lt;z\\). 序与加法及减法 \\(1\\tdeg\\) \\(0&lt;1\\). \\(2\\tdeg\\) 若 \\(0&lt;x\\) 则 \\(0&lt;x^{-1}\\). 若 \\(0&lt;x\\), \\(x&lt;y\\), 则 \\(0&lt;y^{-1}\\), \\(y^{-1}&lt;x^{-1}\\). 由完备定理, 我们可以得到关于上下界的一些比较好的性质. 首先有一些关于上下界的定义: 上界与下界 设 \\(X\\subseteq\\mbb R\\), 若 \\(\\exists c\\in\\mbb R\\), s.t. \\(\\forall x\\in X\\) 都有 \\(x\\le c\\), 就称 \\(X\\) 是上有界集, \\(c\\) 是 \\(X\\) 的的一个上界. 将上述定义中的 \\(\\le\\) 改为 \\(\\ge\\), 就得到了下有界集和下界的定义. 既有上界又有下界的集合叫做有界集. 极大元与极小元 设 \\(X\\subseteq\\mbb R,a\\in X\\), 若 \\(\\forall x\\in X\\), 都有 \\(x\\le a\\), 那么称 \\(a\\) 为 \\(x\\) 的最大元或极大元, 记做 \\(\\max X\\). 将上述定义中的 \\(\\le\\) 改为 \\(\\ge\\), 就得到了极小元的定义, 记做 \\(\\min X\\). 一个集合不一定存在极大元或极小元. 极大元或极小元若存在, 则只能有一个. 上确界与下确界 设 \\(X\\subseteq\\mbb R\\): \\(X\\) 的上界中的最小者称为 \\(X\\) 的上确界, 记做 \\(\\sup X\\). \\(X\\) 的下界中的最大者称为 \\(X\\) 的下确界, 记做 \\(\\inf X\\). 即 \\[ \\begin{aligned} \\sup X&amp;:=\\min\\lrac{c\\in\\mbb R|\\forall x\\in X,x\\le c}\\\\ \\inf X&amp;:=\\min\\lrac{c\\in\\mbb R|\\forall x\\in X,c\\le x}\\\\ \\end{aligned} \\] 通过这种定义得到的上确界和下确界的存在性是未知的. 但是我们由下面的定理可知上下确界是一定存在的. 上确界原理 实数集的任何非空有上界的子集有唯一的上确界. 证明: 设 \\(X\\) 是给定的集合, \\(Y=\\lrac{y\\in\\mbb R|\\forall x\\in X,x\\le y}\\) 是上界构成的集合. 由定义可知, \\(\\forall x\\in X,y\\in Y\\), \\(x\\le y\\). 由题意知, \\(x\\ne\\eset,y\\ne\\eset\\). 由完备公理, \\(\\exists c\\in\\mbb R\\) s.t. \\(\\forall x\\in X,y\\in Y\\), \\(x\\le c\\le y\\). 于是 \\(c\\) 是 \\(x\\) 的上界, \\(c\\in Y\\). 于是 \\(c\\) 是 \\(Y\\) 的极小元, \\(c=\\min Y=\\sup X\\). 证毕. 类似的, 可以有下确界原理: 实数集的任何非空有下界的子集有唯一的下确界. 至此, 我们定义了实数集的公理系统, 似乎这篇报告到这里就可以结束了. 但是我们回顾一下之前我们定义实数集的过程: 自然数集, 整数集, 有理数集, 实数集. 但是现在按上述定义, 我们只定义了实数集! 前面的自然数集, 整数集和有理数集都还没有定义! 也就是说, 我们的工作还没有完成! 下面就开始定义其他的那些集合. 在定义自然数集之前, 先定义归纳集: 归纳集 设 \\(X\\subseteq\\mbb R\\), 若 \\(\\forall x0\\in X\\), 有 \\(x+1\\in X\\), 就称 \\(X\\) 为一个归纳集. 例如: \\(\\mbb R\\) 和 \\(\\mbb R_+\\) 都是归纳集. 命题 任意多个归纳集 \\(X_\\alpha\\) 之交集 \\(\\bigf X=\\bigcap_{\\alpha\\in A}X_\\alpha\\) 若非空, 则 \\(X\\) 也是归纳集. 证明: \\(\\forall x\\in X\\): \\(\\forall\\alpha\\in A\\), \\(x\\in X_\\alpha\\). 于是 \\(\\forall\\alpha\\in A\\), \\(x+1\\in X_\\alpha\\). 于是 \\(x+1\\in X\\). \\(X\\) 是归纳集. 证毕. 自然数集 包含数 \\(1\\) 的最小归纳集叫自然数集, 用 \\(\\mbb N\\) 表示, 其元素叫自然数. 容易发现, 自然数集就是由 \\(1\\), \\(1+1\\), \\((1+1)+1\\) 组成的集合. 数学归纳原理 若 \\(E\\subseteq\\mbb N\\), \\(1\\in E\\), 且 \\(\\forall x\\in E\\), \\(x+1\\in E\\). 则 \\(E=\\mbb N\\). 证明: 由归纳集定义, \\(E\\) 是归纳集. 又 \\(1\\in E\\), 由自然数集定义, \\(\\mbb N\\subseteq E\\). 又 \\(E\\subseteq\\mbb N\\), 于是 \\(E=\\mbb N\\). 证毕. 自然数集的部分性质 \\(1\\tdeg\\) 自然数的和与积是自然数. 证明: \\[ A:=\\lrac{n\\in\\mbb N|\\forall m\\in\\mbb N,m+n\\in\\mbb N}\\subseteq\\mbb N \\] 由自然数定义, \\(1\\in A\\). \\(\\forall n\\in A\\), \\(\\forall m\\in\\mbb N\\), \\(m+n\\in\\mbb N\\), \\(m+(n+1)=(m+n)+1\\in\\mbb N\\). 于是 \\(n+1\\in A\\). 于是由数学归纳原理 \\(A=\\mbb N\\). 于是自然数的和是自然数. \\[ B:=\\lrac{n\\in\\mbb N|\\forall m\\in\\mbb N,m\\cdot n\\in\\mbb N}\\subseteq\\mbb N \\] 由 \\(1\\) 的定义, \\(1\\in B\\). \\(\\forall n\\in B\\), \\(\\forall m\\in\\mbb N\\), \\(m\\cdot n\\in\\mbb N\\), \\(m\\cdot(n+1)=m\\cdot n+m\\in\\mbb N\\). 于是 \\(n+1\\in B\\). 于是由数学归纳原理 \\(B=\\mbb N\\). 于是自然数的积是自然数. 证毕. 用类似的方法可以证明 \\(2\\tdeg-5\\tdeg\\)： \\(2\\tdeg\\) 若 \\(n\\in\\mbb N\\), \\(n\\ne1\\), 则 \\(n-1\\in\\mbb N\\). \\(3\\tdeg\\) \\(\\forall n\\in\\mbb N\\), \\(\\lrac{x\\in\\mbb N|n&lt;x}\\) 有极小元 \\(n+1\\). \\(4\\tdeg\\) \\(\\forall m,n\\in\\mbb N\\), 若 \\(n&lt;m\\), 则 \\(n+1\\le m\\). \\(5\\tdeg\\) 若 \\(n\\in\\mbb N\\), 则没有 \\(x\\in\\mbb N\\) 能满足 \\(n&lt;x&lt;n+1\\). \\(6\\tdeg\\) 自然数集的任何非空子集都有最小元. 证明: 设 \\(M\\subseteq\\mbb N\\), \\(M\\ne\\eset\\). 若 \\(1\\in M\\), 则 \\(\\min M=1\\). 否则, 设 \\(E=\\mbb N\\bksl M\\), \\(1\\in E\\). 在 \\(E\\) 中必能找到自然数 \\(n\\in E\\) s.t. 不超过 \\(n\\) 的自然数都在 \\(E\\) 中而 \\(n+1\\in M\\). 否则 \\(1\\in E\\subseteq\\mbb N\\), 当 \\(n\\in E\\) 时, \\(n+1\\in E\\), 于是 \\(E=\\mbb N\\), \\(M=\\eset\\), 矛盾. \\(n+1\\in M\\) 即 \\(M\\) 的最小元, 因为 \\(n\\) 与 \\(n+1\\) 之间没有自然数. 其实我不是很能理解这个证明, 有点循环论证的感觉. 整数 自然数集, 自然数的相反数的集合, 以及 \\(\\lrac0\\) 的并集叫做整数集, 记做 \\(\\mbb Z\\). 整数对加法和乘法运算封闭. \\(\\mbb Z\\) 关于加法运算构成 Abel 群. 有了整数的定义, 就能得到初等数论中的关于整数的一些性质, 这里不做赘述. 对比之前我们由自然数得到整数的过程, 我们使用的是 \\(\\mbb N\\times\\mbb N\\) 的商集得到的 \\(\\mbb Z\\) 的. 但是现在我们先定义了 \\(\\mbb R\\), 于是就有了相反数, 在定义 \\(\\mbb Z\\) 时就简洁了许多. 有理数 形如 \\(m\\cdot n^{-1}\\) 的数叫有理数, 其中 \\(m,n\\in\\mbb Z\\). 有理数构成的集合叫有理数集, 用 \\(\\mbb Q\\) 表示. 有理数 \\(q=m\\cdot n^{-1}\\) 也可以写成有理分数 \\(\\bigf\\frac{m}n\\) 的形式. “小学生都知道”, \\(\\forall k\\in\\mbb Z\\), 若 \\(k\\ne0\\), 则 \\(\\bigf\\frac{m}{n}=\\frac{mk}{nk}\\). 下面简单地证明这件事: 由结合性, \\((nk)(k^{-1}n^{-1})=1\\), \\(k^{-1}n^{-1}=(nk)^{-1}\\). 于是 \\((mk)(nk)^{-1}=mk(k^{-1}n^{-1})=m\\cdot n^{-1}\\). 于是 \\(\\forall m\\cdot n^{-1}\\), \\(k:=\\gcd(m,n)\\), 于是 \\(m=m&#39;k,n=n&#39;k\\), 其中 \\(m&#39;,n&#39;\\in\\mbb Z\\), \\(\\gcd(m,n)=1\\). 由小学生都知道的结论, \\(m\\cdot n^{-1}=m&#39;\\cdot n&#39;^{-1}\\). 于是每个有理数经过约分后, 都能用互素的整数有序对给出. 无理数 不是有理数的实数叫无理数. 下面构造一个无理数 \\(\\sqrt2\\) 以证明无理数是存在的. 构造集合 \\(X=\\lrac{x|x^2&lt;2}\\), \\(Y=\\lrac{y|2&lt;y^2}\\). 显然, \\(1\\in X,2\\in Y\\), 且 \\(\\forall x\\in X,y\\in Y\\), \\(x\\le y\\). 于是由完备公理, \\(\\exists t\\in\\mbb R\\) s.t. \\(\\forall x\\in X,y\\in Y\\), \\(x\\le t\\le y\\). 记 \\(p=2-t^2\\), \\(a=t+\\cfrac{p}{3t}\\). 由于 \\(1\\in x,2\\in y\\), 于是 \\(1\\le t\\le2\\), 于是 \\(-2\\le p\\le1\\). \\(1\\le t\\le t^2\\), \\(p^2\\le p\\). 若 \\(t^2&lt;2\\), 则 \\(p&gt;0\\), \\(a&gt;t\\). \\[ a^2=t^2+\\frac23p+\\frac{p^2}{9t^2}\\le t^2+\\frac23p+\\frac19p&lt;t^2+p=2 \\] 于是 \\(a^2\\in X\\), \\(a^2&gt;t^2\\), 矛盾. 若 \\(t^2&gt;2\\), 则 \\(p&lt;0\\), \\(a&lt;t\\). \\[ a^2=t^2+\\frac23p+\\frac{p^2}{9t^2}\\ge t^2+\\frac23p&gt;t^2+p=2 \\] 于是 \\(a^2\\in Y\\), \\(a^2&lt;t^2\\), 矛盾. 于是 \\(t^2=2\\), 也就是所谓的 \\(\\sqrt2:=t\\) 是存在的.下面证明 \\(\\sqrt2\\) 是无理数. 若 \\(\\sqrt2\\) 是有理数, 设 \\(\\sqrt2=\\cfrac{m}n\\), \\(m,n\\in\\mbb Z\\), \\(\\gcd(m,n)=1\\). 于是 \\(m^2=2n^2\\). 由 \\(2\\mid m^2\\), \\(2\\mid m\\). 于是设 \\(m=2k\\), \\((2k)^2=2n^2\\), \\(2k^2=n^2\\), \\(2\\mid n\\), 于是 \\(\\gcd(m,n)\\ge2\\), 矛盾. 于是 \\(\\sqrt2\\) 是无理数. 代数数与超越数 一个实数若是某个整系数多项式代数方程的根, 那么这个实数叫做代数数, 否则叫做超越数. \\(\\sqrt2\\) 是方程 \\(x^2=2\\) 的根, 是代数数. \\(e\\)[3] 和 \\(\\pi\\)[4] 都是超越数, 结论是广为人知的, 但是证明很复杂, 在参考资料中有证明. 总之, 代数数和超越数都是存在的. 完备公理的应用 前面的结论的证明中, 只有证明上下确界原理和 \\(\\sqrt2\\) 的存在性中使用到了完备公理. 关于完备公理有下述结论: \\(1\\tdeg\\) 自然数集的任何非空有界子集有极大元. 证明: 设 \\(E\\subseteq\\mbb N\\) 是一不空有界集, 记 \\(s:=\\sup E\\in\\mbb R\\). 由于 \\(s\\) 是上确界, 于是 \\(s-1\\) 不是 \\(E\\) 的上界, 于是一定 \\(\\exists n\\in E\\), s.t. \\(s-1&lt;n\\). 于是 \\(s&lt;n+1\\). \\(\\forall x\\in E\\), \\(x\\le s&lt;n+1\\). 就是 \\(\\forall x\\in E\\), \\(x\\le n\\). 于是 \\(n=\\max E\\). 用类似的方法可以证明 \\(2\\tdeg-5\\tdeg\\)： \\(2\\tdeg\\) 自然数集的任何非空有界子集有极小元. \\(3\\tdeg\\) 自然数集没有上界. \\(4\\tdeg\\) 整数集的任何上有界非空子集有极大元和极小元. \\(5\\tdeg\\) 整数集没有上下界. \\(6^\\circ\\) 阿基米德原理 若 \\(h&gt;0\\), 则 \\(\\forall x\\in\\mbb R\\), 有唯一地整数 \\(k\\) s.t. \\((k-1)h\\le x&lt;kh\\). 证明: \\(\\mbb Z\\) 无上界, 于是 \\(\\lrac{n\\in\\mbb Z\\bigg|\\cfrac{x}h&lt;n}\\) 是 \\(\\mbb Z\\) 的非空下有界子集, 于是有极小元 \\(k\\). 于是 \\(k-1\\le\\cfrac{x}h&lt;k\\). 于是 \\((k-1)h\\le x&lt;kh\\). 阿基米德原理有以下推论： \\(7\\tdeg\\) \\(\\forall\\varepsilon&gt;0\\), \\(\\exists n\\in\\mbb N\\), s.t. \\(0&lt;\\cfrac1n&lt;\\varepsilon\\). \\(8\\tdeg\\) 若 \\(x\\in\\mbb R\\), \\(x\\ge0\\), 且 \\(\\forall n\\in\\mbb N\\) 都有 \\(x&lt;\\cfrac1n\\), 则 \\(x=0\\). \\(9\\tdeg\\) \\(\\forall a,b\\in\\mbb R\\), 若 \\(a&lt;b\\) 则 \\(\\exists q\\in\\mbb Q\\) s.t. \\(a&lt;q&lt;b\\). 证明: \\(\\exists n\\in\\mbb N\\), s.t. \\(0&lt;\\cfrac1n&lt;b-a\\). 又 \\(\\exists m\\in\\mbb N\\), s.t. \\(\\cfrac{m-1}n\\le a&lt;\\cfrac{m}n\\). 于是 \\(\\cfrac{m}n\\le a+\\cfrac1n&lt;b\\). 于是 \\(a&lt;\\cfrac{m}n&lt;b\\). 至此, 我们就构建了一个完整的实数域系统, 并给出了一些结论. 这样就可以得到我们在数学分析课程中得到的一些结论. 参考资料 [1] B.A.卓里奇 数学分析(第一卷)(第4版)[M]. 北京: 高等教育出版社, 2006. [2] 全序关系, 维基百科, https://zh.wikipedia.org/zh-hans/全序关系 [3] 如何证明 \\(e\\) 是超越数, 知乎, https://zhuanlan.zhihu.com/p/47709039 [4] 如何证明 \\(\\pi\\) 是超越数, 知乎, https://zhuanlan.zhihu.com/p/56607777 [5] 数学分析笔记（二）——实数理论, 知乎, https://zhuanlan.zhihu.com/p/38393931","categories":[],"tags":[{"name":"数学分析","slug":"数学分析","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"},{"name":"原创","slug":"原创","permalink":"https://sheauhawjang.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"读书报告","slug":"读书报告","permalink":"https://sheauhawjang.github.io/tags/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"}]},{"title":"2020 校赛模拟赛 F 题解","slug":"2020 School Contest Simulation F","date":"2020-04-25T10:28:07.000Z","updated":"2020-08-17T00:50:33.000Z","comments":true,"path":"2020/04/25/2020 School Contest Simulation F/","link":"","permalink":"https://sheauhawjang.github.io/2020/04/25/2020%20School%20Contest%20Simulation%20F/","excerpt":"题目来源: XJTUOJ-1143 ddd和万马奔腾 题目链接: https://oj.skyair.org/problem/1143 题面 数论描述 给定 \\(n\\) 个正整数 \\(m_1,m_2,\\cdots,m_n\\), 判断每个 \\(m\\) 是不是模 \\(p\\) 意义下的 \\(k\\) 次剩余。多个 \\(m\\) 符合条件按从小到大顺序输出. 通俗描述 给定 \\(n\\) 个正整数 \\(m_1,m_2,\\cdots,m_n\\), 判断每个 \\(m\\) 是否满足: \\(\\gcd(m,p)=1\\). 存在一个整数 \\(a\\), 使得 \\(a^k\\equiv m\\pmod p\\). 如果一个数 \\(m\\) 满足上述两个条件, 则称 \\(m\\) 是模 \\(p\\) 意义下的 \\(k\\) 次剩余。多个 \\(m\\) 符合条件按从小到大顺序输出. \\(x\\equiv y\\pmod p\\) 的定义是 \\(p\\mid(x-y)\\), 等价描述是存在整数 \\(b\\) 使得 \\(x-bp=y\\). 数据范围 \\[ 1&lt;k\\le10^5 \\] \\[ 1&lt;p\\le10^5 \\] \\[ 1\\le n,m&lt;p \\]","text":"题目来源: XJTUOJ-1143 ddd和万马奔腾 题目链接: https://oj.skyair.org/problem/1143 题面 数论描述 给定 \\(n\\) 个正整数 \\(m_1,m_2,\\cdots,m_n\\), 判断每个 \\(m\\) 是不是模 \\(p\\) 意义下的 \\(k\\) 次剩余。多个 \\(m\\) 符合条件按从小到大顺序输出. 通俗描述 给定 \\(n\\) 个正整数 \\(m_1,m_2,\\cdots,m_n\\), 判断每个 \\(m\\) 是否满足: \\(\\gcd(m,p)=1\\). 存在一个整数 \\(a\\), 使得 \\(a^k\\equiv m\\pmod p\\). 如果一个数 \\(m\\) 满足上述两个条件, 则称 \\(m\\) 是模 \\(p\\) 意义下的 \\(k\\) 次剩余。多个 \\(m\\) 符合条件按从小到大顺序输出. \\(x\\equiv y\\pmod p\\) 的定义是 \\(p\\mid(x-y)\\), 等价描述是存在整数 \\(b\\) 使得 \\(x-bp=y\\). 数据范围 \\[ 1&lt;k\\le10^5 \\] \\[ 1&lt;p\\le10^5 \\] \\[ 1\\le n,m&lt;p \\] 题解 显然 \\(i^k\\equiv(i\\%p)^k\\pmod p\\). 所有可能是 \\(k\\) 次剩余的数至多有 \\(p-1\\) 个, 他们在 \\(1^k,2^k,\\cdots,(p-1)^k\\pmod p\\) 当中. 将这些数字枚举出来并放入一个 std::set 或 bool 数组进行存储. 对于给定的一个 \\(m\\), 先判断 \\(\\gcd(m,p)\\) 是否为 \\(1\\). 如果是, 再判断上述 \\(p-1\\) 个数字中有没有 \\(m\\). 如果两个条件都符合, 那么 \\(m\\) 就是模 \\(p\\) 意义下的 \\(k\\) 次剩余, 否则就不是. 使用快速幂算法可以在 \\(O(\\log k)\\) 的时间里算出一个 \\(i^k\\), 算出所有可能的 \\(p-1\\) 个数的时间复杂度是 \\(O(p\\log k)\\). 求 \\(\\gcd\\) 使用辗转相除法可以在 \\(O(\\log p)\\) 的时间内求得 \\(\\gcd (m,p)\\). 使用 std::set 进行查询一次的时间复杂度是 \\(O(\\log p)\\), 使用 bool 数组进行查询一次的时间复杂度是 \\(O(1)\\). 于是总时间复杂度就是 \\(O(p\\log k+n\\log p)\\). 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;inline int kpow(ll a, int k, int p)&#123; ll ans = 1; while (k) &#123; if (k &amp; 1) ans *= a, ans %= p; a *= a, a %= p; k &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int k, p, n; vector&lt;int&gt; que; set&lt;int&gt; pop, ans; cin &gt;&gt; k &gt;&gt; p &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; int a; cin &gt;&gt; a; que.push_back(a); &#125; for (int i = 1; i &lt; p; ++i) pop.insert(kpow(i, k, p)); for (int i = 0; i &lt; n; ++i) if (gcd(que[i], p) == 1 &amp;&amp; pop.count(que[i])) ans.insert(que[i]); cout &lt;&lt; ans.size() &lt;&lt; endl; for (int a : ans) cout &lt;&lt; a &lt;&lt; \" \"; return 0;&#125;","categories":[],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"2020 CCPC WannaFly 冬令营 Day5H 题解","slug":"2020 Wannafly Winter 5H","date":"2020-01-18T18:58:24.000Z","updated":"2023-05-27T12:37:09.000Z","comments":true,"path":"2020/01/19/2020 Wannafly Winter 5H/","link":"","permalink":"https://sheauhawjang.github.io/2020/01/19/2020%20Wannafly%20Winter%205H/","excerpt":"题面 在以 \\(O\\) 为球心的单位球面上寻找三个点 \\(A, B, C\\), s.t.: \\[ \\min(|AB|,|BC|,|CA|)\\geq1.7 \\] \\[ 0&lt;d(O,ABC)\\leq10^{-18} \\] 输出格式 每行输出三个整数 \\(x,y,z\\in[-10^{6},10^6]\\cap\\mathbb Z\\), 表示选取了点 \\[ \\left(\\frac{x}{\\sqrt{x^2+y^2+z^2}},\\frac{y}{\\sqrt{x^2+y^2+z^2}},\\frac{z}{\\sqrt{x^2+y^2+z^2}}\\right) \\]","text":"题面 在以 \\(O\\) 为球心的单位球面上寻找三个点 \\(A, B, C\\), s.t.: \\[ \\min(|AB|,|BC|,|CA|)\\geq1.7 \\] \\[ 0&lt;d(O,ABC)\\leq10^{-18} \\] 输出格式 每行输出三个整数 \\(x,y,z\\in[-10^{6},10^6]\\cap\\mathbb Z\\), 表示选取了点 \\[ \\left(\\frac{x}{\\sqrt{x^2+y^2+z^2}},\\frac{y}{\\sqrt{x^2+y^2+z^2}},\\frac{z}{\\sqrt{x^2+y^2+z^2}}\\right) \\] 题解 设原点为 \\(O\\). \\(A,B,C\\) 每个点选取的三个整数分别为 \\(\\boldsymbol A(A_x, A_y, A_z), \\boldsymbol B(B_x, B_y, B_z), \\boldsymbol C(C_x, C_y, C_z)\\), 记： \\[ \\left|\\boldsymbol P\\right|:=\\sqrt{P_x^2+P_y^2+P_z^2},\\quad\\forall \\boldsymbol P\\in\\{\\boldsymbol A,\\boldsymbol B,\\boldsymbol C\\} \\] \\[ D_0:=\\overrightarrow{OA}\\times\\overrightarrow{OB}\\cdot\\overrightarrow{OC}=\\left| \\begin{array}{ccc} \\frac{A_x}{|\\boldsymbol A|} &amp; \\frac{A_y}{|\\boldsymbol A|} &amp; \\frac{A_z}{|\\boldsymbol A|}\\\\ \\frac{B_x}{|\\boldsymbol B|} &amp; \\frac{B_y}{|\\boldsymbol B|} &amp; \\frac{B_z}{|\\boldsymbol B|}\\\\ \\frac{C_x}{|\\boldsymbol C|} &amp; \\frac{C_y}{|\\boldsymbol C|} &amp; \\frac{C_z}{|\\boldsymbol C|}\\\\\\end{array} \\right| \\] \\[ D:= {D_0}{|\\boldsymbol A||\\boldsymbol B||\\boldsymbol C|} = \\left| \\begin{array} {ccc} A_x &amp; A_y &amp; A_z \\\\ B_x &amp; B_y &amp; B_z \\\\ C_x &amp; C_y &amp; C_z \\end{array} \\right| \\] 由三棱锥体积公式，可得： \\[ \\begin{align} V:=V_{OABC} &amp;=\\frac{1}{3}Sh\\\\ &amp;=\\frac{1}{6}|D_0|=\\frac{|D|}{6|\\boldsymbol A||\\boldsymbol B||\\boldsymbol C|} \\end{align} \\] \\[ h=\\frac{|D|}{2S|\\boldsymbol A||\\boldsymbol B||\\boldsymbol C|} \\] 注意到 \\(\\sqrt3\\approx1.7\\), 故尽量选取等边三角形以达到最优。 同时注意到： \\[ D= \\left| \\begin{array} {ccc} 1 &amp; 1 &amp; 0 \\\\ 0 &amp; -1 &amp; 1 \\\\ -1 &amp; 0 &amp; -1 \\end{array} \\right| \\] 满足：\\(D=0\\), \\(|AB|=|BC|=|CA|=\\sqrt3\\). 同理， \\[ D= \\left| \\begin{array} {ccc} 10^6 &amp; 10^6 &amp; 0 \\\\ 0 &amp; -10^6 &amp; 10^6 \\\\ -10^6 &amp; 0 &amp; -10^6 \\end{array} \\right| \\] 有同样的性质，此时： \\[ |\\boldsymbol A|=|\\boldsymbol B|=|\\boldsymbol C|=\\sqrt2\\cdot10^6 \\] \\[ h=\\frac{|D|}{2S|\\boldsymbol A||\\boldsymbol B||\\boldsymbol C|}=\\frac{|D|}{3\\sqrt6\\cdot10^{18}} \\] 微调 \\(\\boldsymbol A,\\boldsymbol B,\\boldsymbol C\\) , s.t. \\(|D|\\leq7\\) 即可。 打表发现：满足条件的一个 \\(D\\) 是： \\[ D=\\left|\\begin{array}{ccc}999999 &amp; 10^6 &amp; 0 \\\\0 &amp; -999999 &amp; 999997 \\\\-999997 &amp; 0 &amp; -999996\\end{array}\\right|=-4 \\] \\[ h=\\frac{|D|}{2S|\\boldsymbol A||\\boldsymbol B||\\boldsymbol C|}\\approx\\frac{4}{3\\sqrt6\\cdot10^{18}}&lt;10^{-18} \\]","categories":[{"name":"2020 CCPC WannaFly 冬令营","slug":"2020-CCPC-WannaFly-冬令营","permalink":"https://sheauhawjang.github.io/categories/2020-CCPC-WannaFly-%E5%86%AC%E4%BB%A4%E8%90%A5/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"计算几何","slug":"计算几何","permalink":"https://sheauhawjang.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"打表","slug":"打表","permalink":"https://sheauhawjang.github.io/tags/%E6%89%93%E8%A1%A8/"}]},{"title":"2020 CCPC WannaFly 冬令营 Day2H 题解","slug":"2020 Wannafly Winter 2H","date":"2020-01-18T14:01:51.000Z","updated":"2020-01-18T14:01:51.000Z","comments":true,"path":"2020/01/18/2020 Wannafly Winter 2H/","link":"","permalink":"https://sheauhawjang.github.io/2020/01/18/2020%20Wannafly%20Winter%202H/","excerpt":"题面 现有一个整数 \\(m\\), 构造了一个长度为 \\(n\\) 的序列 \\(A\\), 满足: 1. \\(\\forall a \\in A,\\, a\\in[1,m]\\cap\\mathbb Z\\) 2. \\(\\forall x,y\\in[1,m]\\cap\\mathbb Z,\\,x\\ne y\\), \\(\\exists p\\in[1,n)\\cap\\mathbb Z\\), s.t. \\(\\{A[p],A[p+1]\\}=\\{x,y\\}\\) 其中 \\(A[p]\\) 表示 \\(A\\) 中的第 \\(p\\) 个元素的值. 给定一个 \\(n\\), 求 \\(m\\) 可能的最大值. 若 \\(n\\leq N=2\\cdot10^6\\), 则再输出 \\(m\\) 取得最大值时可能的一个序列 \\(A\\). 数据范围 \\[ 1\\leq n\\leq10^{18} \\]","text":"题面 现有一个整数 \\(m\\), 构造了一个长度为 \\(n\\) 的序列 \\(A\\), 满足: 1. \\(\\forall a \\in A,\\, a\\in[1,m]\\cap\\mathbb Z\\) 2. \\(\\forall x,y\\in[1,m]\\cap\\mathbb Z,\\,x\\ne y\\), \\(\\exists p\\in[1,n)\\cap\\mathbb Z\\), s.t. \\(\\{A[p],A[p+1]\\}=\\{x,y\\}\\) 其中 \\(A[p]\\) 表示 \\(A\\) 中的第 \\(p\\) 个元素的值. 给定一个 \\(n\\), 求 \\(m\\) 可能的最大值. 若 \\(n\\leq N=2\\cdot10^6\\), 则再输出 \\(m\\) 取得最大值时可能的一个序列 \\(A\\). 数据范围 \\[ 1\\leq n\\leq10^{18} \\] 题解 构造一个 \\(m\\) 个顶点的无向图 \\(\\boldsymbol G\\), \\(\\forall p\\in [1,n)\\), 在 \\(A[p]\\) 和 \\(A[p+1]\\) 之间连一条边, 记作第一类边. 则 \\(A\\) 的条件 \\((2)\\) 就转化成了 \\(\\boldsymbol G\\) 中任意两个不同点都要有边直接连接, 最多有 \\(n-1\\) 条边. 这样, 我们就得到了 \\(n\\) 的一个下界: \\[ n\\geq\\frac{1}{2}m(m-1)+1 \\tag{3} \\] 等号成立当且仅当任意两个不同点之间直接连接的边有且仅有 \\(1\\) 条. 另一方面, 观察这些连接的边: \\[ A[1]\\rightarrow A[2]\\rightarrow A[3]\\rightarrow...\\rightarrow A[n] \\] 考虑从 \\(A[1]\\) 号点出发, 按照上述顺序遍历整个图, 发现每条边经过且只经过了一次, 这对应了一个欧拉回路, 于是 \\(\\boldsymbol G\\) 中至多两个点的度数为奇数. 反过来, 如果 \\(\\boldsymbol G\\) 中至多两个点的度数为奇数, 那么可以构造出这样一个欧拉回路以及对应的序列. 考虑以上两个要素: 任意两个不同点之间直接连接的边有且仅有一条时, 每个点的度数是 \\(m-1\\). 如果 \\(m\\) 是奇数, 那么每个点的度数全部都是偶数, 故可以构造出一个序列 \\(A\\). \\((3)\\) 式等号可以成立. 如果 \\(m\\) 是偶数, 那么每个点的度数全部都是奇数, \\(m&gt;2\\) 时不能构造出一个欧拉回路. 这时, 我们可以任取 \\(m-2\\) 个度数为奇数的点, 配对连边, 记作第二类边. 于是这 \\(m-2\\) 个点度数均加 \\(1\\), 变为了偶数. 这样 \\(G\\) 中只有 \\(2\\) 个点度数为奇数, 可以构造欧拉回路. 此时有: \\[ n\\geq\\frac{1}{2}m(m-1)+1+\\frac{1}{2}(m-2)=\\frac{1}{2}m^2 \\] 综上所述, 定义: \\[ f(m):=\\left\\{ \\begin{align} \\frac{1}{2}m(&amp;m-1)+1 &amp; m\\equiv 0\\pmod 2\\\\ \\frac{1}{2}&amp;m^2 &amp; m\\equiv 1\\pmod 2 \\end{align}\\right. \\] 条件便可以总结为: \\[ n\\geq f(m) \\tag4 \\] 我们可以从 \\(1\\) 到 \\(n\\) 枚举所有可能的 \\(m\\), 取其中满足 \\(n\\geq f(m)\\) 的最大值. 复杂度为 \\(O(n)\\), 不能接受. 注意到: \\(\\forall m\\equiv 0\\pmod 2\\), \\(\\displaystyle \\frac{1}{2}(m-1)(m-2)+1&lt;\\frac{1}{2}m^2&lt;\\frac{1}{2}m(m+1)+1\\). 即: \\(\\forall m\\in\\mathbb N_+\\), \\(f(m)&lt;f(m+1)\\). \\(f\\) 严格单调增, 故可以使用二分查找, 复杂度为 \\(O(\\log n)\\), 可以接受. 也可以分别解不等式: \\[ \\begin{align} \\frac{1}{2}x(x-1)+1&amp;\\le n \\tag5\\\\ \\frac{1}{2}x^2&amp;\\le n \\tag6 \\end{align} \\] 取不等式 \\((4)\\) 解中最大的奇数和不等式 \\((5)\\) 解中最大的偶数的较大者, 复杂度为 \\(O(1)\\). 很好. 现在思考一种 \\(\\forall m\\in\\mathbb N_+\\) 都能构造欧拉回路以及对应的序列 \\(A\\) 的方法. 先考虑 \\(n=f(m)\\) 的情况, 这种情况构造的序列记作 \\(A_m\\), 此时 \\(A=A_m\\). 对于 \\(m\\) 是奇数的情况, 考虑数学归纳法: 一、\\(m=1\\) 时, 由于没有边, 欧拉环路显然存在, \\(A_1=[1]\\). 二、设我们构造出了 \\(m=k\\) 时的图的欧拉环路以及对应的序列 \\(A_k\\). 显然, 欧拉环路可以从任意一个点出发, 遍历一遍图后回到起点. \\(A[1]\\) 可以是任意一个数, \\(A[n]=A[1]\\). 不妨令 \\(A[1]=A[n]=1\\). 现在我们加入两个点 \\(k+1,k+2\\). 考虑序列 \\(B=[2,3,...,k]\\), 在 \\(B\\) 中所有的奇数前面插入 \\(k+1\\), 后面插入 \\(k+2\\), 则 \\(B=[2,k+1,3,k+2,...,k+1,k,k+2]\\). 令 \\(A_{k+2}=[A_k,k+1,k+2,B,1]\\). 这样, \\(m=k+2\\) 时的序列以及对应的欧拉回路就构造好了. 对于 \\(m\\) 时偶数的情况, 考虑数学归纳法: 一、\\(m=2\\) 时, 由于只有一条边, 欧拉环路显然存在, \\(A_2=[1,2]\\). 二、设我们构造出了 \\(m=k\\) 时的图的欧拉环路以及对应的序列 \\(A_k\\). 显然, 欧拉环路应该从一个度数为奇数的点出发, 遍历一遍图后回到另一个度数为奇数的点. \\(A[1],A[n]\\) 可以是任意两个不同的数, 不妨令 \\(A[1]=1,A[n]=k\\). 现在我们加入两个点 \\(k+1,k+2\\). 将 \\(k,k+1\\) 配对连接第二类边. 考虑序列 \\(B=[2,3,...,k]\\), 在 \\(B\\) 中所有的奇数前面插入 \\(k+1\\), 后面插入 \\(k+2\\), 则 \\(B=[2,k+1,3,k+2,...,k+1,k,k+2]\\). 令 \\(A_{k+2}=[A_k,k+1,k+2,B]\\). 这样, \\(m=k+2\\) 时的序列以及对应的欧拉回路就构造好了. 当然, 这个构造只是一种构造. 其他的任何满足题意的构造均可行. 现在考虑 \\(n&gt;f(m)\\) 的情况. 很显然, 令 \\(A=[A_m,\\underbrace{1,1,...,1}_{n-f(m)}]\\) 即可. 构造复杂度为 \\(O(N)\\). 可以接受. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll get(ll m)&#123; if (m &amp; 1) return (m * (m - 1) &gt;&gt; 1) + 1; return m * m &gt;&gt; 1;&#125;bool check(ll m, ll n)&#123; return get(m) &lt;= n;&#125;ll rget(ll n, ll l, ll r)&#123; if (l + 1 == r) return l; ll mid = l + r &gt;&gt; 1; if (check(mid, n)) return rget(n, mid, r); return rget(n, l, mid);&#125;void opt(ll m)&#123; if (m &amp; 1) &#123; printf(\"1\"); int o = 1, n = 1; for (int i = 2; i &lt; m; i += 2) &#123; printf(\" %d\", i); n = i; do &#123; o = o % (i - 1) + 1; n = n == i ? i + 1 : i; printf(\" %d %d\", n, o); &#125; while (o != 1 || n != i + 1); &#125; &#125; else &#123; printf(\"1 2\"); int o = 2, n = 1; for (int i = 3; i &lt; m; i += 2) &#123; printf(\" %d\", i); n = i; do &#123; o = o % (i - 1) + 1; n = n == i ? i + 1 : i; printf(\" %d %d\", n, o); &#125; while (o != i - 1 || n != i); printf(\" %d\", o = i + 1); &#125; &#125;&#125;int main()&#123; ll n; scanf(\"%lld\", &amp;n); ll m = rget(n, 0, 2e9); printf(\"%lld\\n\", m); if (n &lt;= 2e6) &#123; opt(m); for (int i = get(m); i &lt; n; ++i) printf(\" 1\"); &#125; return 0;&#125;","categories":[{"name":"2020 CCPC WannaFly 冬令营","slug":"2020-CCPC-WannaFly-冬令营","permalink":"https://sheauhawjang.github.io/categories/2020-CCPC-WannaFly-%E5%86%AC%E4%BB%A4%E8%90%A5/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"https://sheauhawjang.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"构造","slug":"构造","permalink":"https://sheauhawjang.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"二分查找","slug":"二分查找","permalink":"https://sheauhawjang.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"2020 CCPC WannaFly 冬令营 Day5J 题解","slug":"2020 Wannafly Winter 5J","date":"2020-01-18T13:33:30.000Z","updated":"2020-01-18T13:33:30.000Z","comments":true,"path":"2020/01/18/2020 Wannafly Winter 5J/","link":"","permalink":"https://sheauhawjang.github.io/2020/01/18/2020%20Wannafly%20Winter%205J/","excerpt":"题面 给定一个整数 \\(k\\) 以及一个 \\(2^k\\times2^k\\) 矩阵 \\(\\boldsymbol A\\) , \\(\\boldsymbol A\\) 中任一元素 \\(a_{ij}\\) 都有 \\(a_{ij}\\in\\{0,1\\}\\). 定义平移 \\(m\\times n\\) 矩阵 \\(\\boldsymbol X\\) 操作如下: \\[ \\boldsymbol X=\\left[\\begin{array} {cc} \\boldsymbol A &amp; \\boldsymbol B\\\\ \\boldsymbol C &amp; \\boldsymbol D \\end{array} \\right] :\\Longrightarrow \\boldsymbol X \\rightarrow \\left[\\begin{array} {cc} \\boldsymbol D &amp; \\boldsymbol C\\\\ \\boldsymbol B &amp; \\boldsymbol A \\end{array} \\right] \\] 其中 \\(\\boldsymbol A\\) 是 \\(a\\times b\\) 矩阵, \\(a\\in[0,m]\\cap\\mathbb Z,b\\in[0,n]\\cap\\mathbb Z\\). 定义用矩阵 \\(\\boldsymbol B\\) 覆盖矩阵 \\(\\boldsymbol A\\) 操作如下: \\[ \\boldsymbol B(b_{ij})\\sim \\boldsymbol A(a_{ij}) :\\Longrightarrow \\boldsymbol A\\rightarrow (a_{ij}\\,\\mathrm{xor}\\,b_{ij}) \\] 你可以选择任意多个经过任意平移操作后的 \\(\\boldsymbol A\\) 依次覆盖一个 \\(\\boldsymbol{0}\\) 矩阵, 求最终可以得到多少种不同的矩阵. 数据范围 \\[ 1\\leq k\\leq5 \\]","text":"题面 给定一个整数 \\(k\\) 以及一个 \\(2^k\\times2^k\\) 矩阵 \\(\\boldsymbol A\\) , \\(\\boldsymbol A\\) 中任一元素 \\(a_{ij}\\) 都有 \\(a_{ij}\\in\\{0,1\\}\\). 定义平移 \\(m\\times n\\) 矩阵 \\(\\boldsymbol X\\) 操作如下: \\[ \\boldsymbol X=\\left[\\begin{array} {cc} \\boldsymbol A &amp; \\boldsymbol B\\\\ \\boldsymbol C &amp; \\boldsymbol D \\end{array} \\right] :\\Longrightarrow \\boldsymbol X \\rightarrow \\left[\\begin{array} {cc} \\boldsymbol D &amp; \\boldsymbol C\\\\ \\boldsymbol B &amp; \\boldsymbol A \\end{array} \\right] \\] 其中 \\(\\boldsymbol A\\) 是 \\(a\\times b\\) 矩阵, \\(a\\in[0,m]\\cap\\mathbb Z,b\\in[0,n]\\cap\\mathbb Z\\). 定义用矩阵 \\(\\boldsymbol B\\) 覆盖矩阵 \\(\\boldsymbol A\\) 操作如下: \\[ \\boldsymbol B(b_{ij})\\sim \\boldsymbol A(a_{ij}) :\\Longrightarrow \\boldsymbol A\\rightarrow (a_{ij}\\,\\mathrm{xor}\\,b_{ij}) \\] 你可以选择任意多个经过任意平移操作后的 \\(\\boldsymbol A\\) 依次覆盖一个 \\(\\boldsymbol{0}\\) 矩阵, 求最终可以得到多少种不同的矩阵. 数据范围 \\[ 1\\leq k\\leq5 \\] 题解 定义数域 \\(B=\\{0,1\\}\\) 上的加法和数量乘法运算: \\[ \\begin{align} \\forall a, b\\in B, \\quad&amp;a\\oplus b =a \\,\\mathrm{xor}\\, b\\\\ &amp;a\\odot b = a \\cdot b \\end{align} \\] 考虑 \\(m\\times n\\) 的矩阵 $ A M_{mn}(B)$, 对 \\(\\boldsymbol A(1; 1)\\) 做一个标记, 则对这个矩阵进行平移操作后, 标记可能在任意一个位置, 有 \\(m\\times n\\) 种取值. 故最多有 $ m n$ 个操作算子 \\(\\boldsymbol F\\). 定义数域 \\(B\\) 上矩阵的加法和数量乘法运算: \\[ \\begin{aligned} &amp; \\forall \\boldsymbol X(x_{ij}), \\boldsymbol Y(y_{ij})\\in M_{m\\times n}(B), &amp; \\boldsymbol X\\oplus \\boldsymbol Y&amp;=(x_{ij}\\oplus y_{ij})\\\\ &amp; \\forall a\\in B, \\boldsymbol X(x_{ij})\\in M_{m\\times n}(B), &amp; a\\odot \\boldsymbol X&amp;=(a\\odot x_{ij}) \\end{aligned} \\] 这样, $ M_{mn}(B) $ 构成了数域 \\(B\\) 上的线性空间. 显然, \\(\\langle\\boldsymbol F \\rangle\\) 是 \\(M_{m\\times n}(B)\\) 的一个线性子空间. 我们需要求的就是 \\(|\\langle\\boldsymbol F\\rangle|\\). 考虑 \\(\\langle\\boldsymbol F \\rangle\\) 的一个基 \\(\\mathfrak B=\\{\\lambda_i;i\\in[1, \\mathrm{rank}\\langle\\boldsymbol F\\rangle]\\cap\\mathbb Z\\}\\), 则 \\(\\forall \\boldsymbol X \\in \\langle \\boldsymbol F\\rangle\\), \\(\\boldsymbol X\\) 可以被 \\(\\mathfrak B\\) 惟一地线性表出, 即存在唯一的一组 \\(k_i\\in B,i\\in[1, |\\mathfrak B|]\\cap\\mathbb Z\\), s.t. \\[ \\boldsymbol X=\\sum_{i=1}^{|\\mathfrak B|}k_i\\lambda_i \\] \\(\\forall i\\in[1,|\\mathfrak B|]\\cap \\mathbb Z,k_i\\) 一共有 \\(0,1\\) 两个取值, 故 \\(\\boldsymbol X\\) 共有 \\(2^{|\\mathfrak B|}\\) 种不同的取值. 线性空间 \\(M_{m\\times n}(B)\\) 与 \\(B^{m\\times n}\\) 同构. 将所有的 \\(m\\times n\\) 个 \\(\\boldsymbol F\\) 转化成 \\(m\\times n\\) 个 \\(m\\times n\\) 维向量, 放入矩阵中高斯消元求秩即可. 复杂度为 \\(O(m^3n^3)=O(2^{6k})\\). 位运算与高斯消元的常数极小, 可以接受. 算出矩阵的秩后, 答案即 \\[ 2^{|\\mathfrak B|}=2^{\\mathrm{rank}\\langle\\boldsymbol F\\rangle} \\] 在 \\(\\bmod p\\) 意义下进行快速幂即可.","categories":[{"name":"2020 CCPC WannaFly 冬令营","slug":"2020-CCPC-WannaFly-冬令营","permalink":"https://sheauhawjang.github.io/categories/2020-CCPC-WannaFly-%E5%86%AC%E4%BB%A4%E8%90%A5/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"线性基","slug":"线性基","permalink":"https://sheauhawjang.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-11T13:11:47.000Z","updated":"2019-12-11T13:11:47.000Z","comments":true,"path":"2019/12/11/hello-world/","link":"","permalink":"https://sheauhawjang.github.io/2019/12/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"2023 ICPC","slug":"2023-ICPC","permalink":"https://sheauhawjang.github.io/categories/2023-ICPC/"},{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/categories/C/"},{"name":"2020 校队夏季训练","slug":"2020-校队夏季训练","permalink":"https://sheauhawjang.github.io/categories/2020-%E6%A0%A1%E9%98%9F%E5%A4%8F%E5%AD%A3%E8%AE%AD%E7%BB%83/"},{"name":"2020 小学期","slug":"2020-小学期","permalink":"https://sheauhawjang.github.io/categories/2020-%E5%B0%8F%E5%AD%A6%E6%9C%9F/"},{"name":"2020 CCPC WannaFly 冬令营","slug":"2020-CCPC-WannaFly-冬令营","permalink":"https://sheauhawjang.github.io/categories/2020-CCPC-WannaFly-%E5%86%AC%E4%BB%A4%E8%90%A5/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://sheauhawjang.github.io/tags/ICPC/"},{"name":"BFS","slug":"BFS","permalink":"https://sheauhawjang.github.io/tags/BFS/"},{"name":"数论","slug":"数论","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"C#","slug":"C","permalink":"https://sheauhawjang.github.io/tags/C/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sheauhawjang.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sheauhawjang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包","slug":"背包","permalink":"https://sheauhawjang.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"bitset","slug":"bitset","permalink":"https://sheauhawjang.github.io/tags/bitset/"},{"name":"图论","slug":"图论","permalink":"https://sheauhawjang.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"构造","slug":"构造","permalink":"https://sheauhawjang.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"高精度","slug":"高精度","permalink":"https://sheauhawjang.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"原创","slug":"原创","permalink":"https://sheauhawjang.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"模板","slug":"模板","permalink":"https://sheauhawjang.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"数学分析","slug":"数学分析","permalink":"https://sheauhawjang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"},{"name":"读书报告","slug":"读书报告","permalink":"https://sheauhawjang.github.io/tags/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"},{"name":"计算几何","slug":"计算几何","permalink":"https://sheauhawjang.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"打表","slug":"打表","permalink":"https://sheauhawjang.github.io/tags/%E6%89%93%E8%A1%A8/"},{"name":"二分查找","slug":"二分查找","permalink":"https://sheauhawjang.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"线性基","slug":"线性基","permalink":"https://sheauhawjang.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"}]}